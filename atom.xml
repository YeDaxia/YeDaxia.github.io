<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叶大侠的主页</title>
  <subtitle>纸上得来终觉浅，绝知此时要躬行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yedaxia.github.io/"/>
  <updated>2019-04-12T14:24:33.591Z</updated>
  <id>https://yedaxia.github.io/</id>
  
  <author>
    <name>叶大侠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谁是李志?</title>
    <link href="https://yedaxia.github.io/Who-is-Li-Zhi/"/>
    <id>https://yedaxia.github.io/Who-is-Li-Zhi/</id>
    <published>2019-04-12T14:02:17.000Z</published>
    <updated>2019-04-12T14:24:33.591Z</updated>
    
    <content type="html"><![CDATA[<p>真正的英雄只有一种，就是认清生活的真相之后，依然热爱它。</p>
<a id="more"></a>
<p>今天一个音乐群里有人发了一句话，然后原本除了发几个小程序，一个月也没几句话的僵尸群突然炸了起来，好奇心很强的我打开看了一下~</p>
<p><img src="/assets/who_is_lizhi_001.png" alt=""></p>
<p><strong>李志是谁？</strong></p>
<blockquote>
<p>1978年，李志生于江苏金坛。<br>1995年，高二的国庆节，李志买了第一把吉他，从此走上音乐的道路。<br>1997年，李志考入位于江苏省南京市的东南大学（东南大学是国内最好的大学之一，985名单里面的）自动控制专业。<br>1998年，李志开始学习作曲。<br>1999年夏天，李志从东南大学退学并前往北京，由于不适应北京环境，不久回到南京。随后几年，李志在南京做过酒吧歌手，民谣吉他教员，琴行工作人员，参加过现拇指姑娘乐队主唱刘子芙在当时组建的胎记乐队，任和声与打击乐手。参与过南京大学《影秋》校园民谣专辑的录制。</p>
</blockquote>
<p>从自动化专业跳到音乐，从顶级的大学退学，这不是一个正常人敢做出的选择~</p>
<p>我不是李志的粉丝，不是特别了解他的过往，偶尔听过他的几首歌，比如《梵高先生》等，感觉比较丧，后来就没怎么听了。</p>
<p>跟一般在舞台上光鲜亮丽的歌手不一样，他长得不算帅，典型的工科男形象。</p>
<p><img src="/assets/who_is_lizhi_002.png" alt=""></p>
<p>他的很多作品歌词很丧，听起来有股绝望的气息。</p>
<p>1、《天空之城》</p>
<pre><code>只不过是一场生活 只不过是一场命运
爱情不过是生活的屁 
折磨着我也折磨着你
</code></pre><p>2、《梵高先生》</p>
<pre><code>谁的父亲死了
请你告诉我如何悲伤
谁的爱人走了
请你告诉我如何遗忘
</code></pre><p>他的声音，说真的，不算好听。</p>
<p><img src="/assets/who_is_lizhi_003.png" alt=""></p>
<p>我一直都很好奇，为什么这么多人喜欢这个人？</p>
<p><img src="/assets/who_is_lizhi_004.png" alt=""><br><img src="/assets/who_is_lizhi_005.png" alt=""></p>
<p>我不知道他的为人如何，但在仔细听了几首作品之后，我可能找到了大家喜欢他的原因。他唱的歌，有种特别难得的真诚。人到中年，有多少人能做到认清现实后，还能做自己，依然热爱生活呢。他确实把我们很多平时不敢说和不敢表达的事情唱到歌里面去了。</p>
<p>这点我钦佩他~</p>
<p><img src="/assets/who_is_lizhi_006.png" alt=""></p>
<blockquote>
<p>李志的独特性不在于声音，而是精神。他们敢言、敢做，为大众带来冲击，让人得到希望和力量（新浪娱乐网评）；</p>
</blockquote>
<blockquote>
<p>李志是一个全能型的独立音乐人和民谣音乐人，他写的作品是民谣的巨作，歌曲写了对社会的抱负还有对生活的美好。他的作品是百听不厌的。（独立音乐人评）</p>
</blockquote>
<p>可能他以后都没办法发歌，也没办法开演唱会了，甚至连他的歌正常途径也没法听到了，但我希望你们对他的热爱，一如既往。</p>
<p><img src="/assets/who_is_lizhi_007.png" alt=""></p>
<p>这个世界本来就是这样子，Ta的好和坏是取决于我们每一个人，请加油，不要把Ta交给你看不起的人。</p>
<p><img src="/assets/who_is_lizhi_008.png" alt=""></p>
<p>最后送上王小波的一句话给B哥：</p>
<blockquote>
<p>在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了槌的牛一样。我觉得自己会永远生猛下去，什么也捶不了我。 – 王小波</p>
</blockquote>
<p>祝好~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真正的英雄只有一种，就是认清生活的真相之后，依然热爱它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="李志" scheme="https://yedaxia.github.io/tags/%E6%9D%8E%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>relearn_music_score</title>
    <link href="https://yedaxia.github.io/relearn-music-score/"/>
    <id>https://yedaxia.github.io/relearn-music-score/</id>
    <published>2019-03-16T04:25:06.000Z</published>
    <updated>2019-03-16T12:21:10.909Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018 的一些事情</title>
    <link href="https://yedaxia.github.io/my-2018-summary/"/>
    <id>https://yedaxia.github.io/my-2018-summary/</id>
    <published>2019-01-13T07:25:38.000Z</published>
    <updated>2019-01-13T16:30:00.590Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>依我看，你所有的问题都可以通过多挣点钱来解决<br>– 生活大爆炸</p>
</blockquote>
<a id="more"></a>
<p><img src="/assets/2018-art-calendar-775779.jpg" alt=""></p>
<p>2019，数了下年轮，不敢相信离30这个数字已经这么近了，无情岁月增中减，一丝惶恐。</p>
<p>29岁，没房没车没女朋友，存款为零。</p>
<p>过得太差，上年的总结迟迟不想写，拖到今天，提醒自己还是要守约，为60岁的自己提供一份回顾人生的蛛丝马迹。</p>
<p>18年初年迈的外婆因癌症离世，有关和童年记忆美好的人和事，似乎都慢慢在逝去，记忆里渐渐模糊，上帝决定要带走一些东西，从来不需要提前跟你打招呼。</p>
<p>时间不停留，万分之一概率的意外也不会说要除了我，有些事情，想好了今天就开始吧，别再辜负年华了。</p>
<p>4 月份回到广州，在一个共享空间租了一个工位，继续开发 C 大调的一些功能，近半年的全栈开发，慢慢从一个脑海里一个简单的想法，到产品设计，到具体的系统设计和编码，都习惯一个人来完成了。</p>
<p>在之前公司当程序员的日子里，其实我和产品经理们相处的还是很愉快的，但内心总有一丝不甘，一个产品的成功，人们通常只会把它和产品经理联系起来，而忘记了在它背后那些亲手把它一砖一瓦搭起来的软件工程师，其实程序员应该是离互联网产品最近的人，可惜国内很多非常厉害的程序员，他们都只满足于实现产品经理们和老板的想法。</p>
<p>找个合伙人的难度远超出我的预想，没有钱不好找人，没有人不好找钱，鸡蛋和鸡的悖论，一度非常焦虑，实则这种焦虑到今天为止其实都没摆脱哈哈。期间买了个蓝牙耳机，坚持每天跑步了一段时间，游泳也还好一周会去一次，这也许一定程度上让我免于抑郁。但作息不规律，天天吃外卖，长期长时间对着电脑屏幕，视力和手指关节都处于亚健康状态。</p>
<p>怕朋友问起最近在做什么，真不知道该怎么回答，从来不敢标榜自己是在创业，只是内心觉得这是一件值得再坚持一下的事情。每次想要放弃的时候，很神奇就有了一个新的想法，总觉得如果把这个新的功能开发出来就能得到认可，即便结果往往只是另一个自嗨和失望。</p>
<p>大部分时间都是在堆积代码，唯一有一些技术挑战的事情就是研究 abc 乐谱语法的解析器了，前后花了将近 2 个月的时间来做了新的乐谱渲染引擎，但还是成了“无用之物”，终究只是技术人的自娱自乐。</p>
<p>用 cloc 统计了一下，一整年大概写了 5 万行左右的代码，其中 Java 的比例最高，其次是 javascript，用了非常多的开源项目，GitHub 是个蕴藏了无数宝藏的地方，这可能是人类历史上最伟大的协作工具之一，如果没有无数这些乐于分享的开发者，所有研究成果和代码都严格商业保密，大家都必须从零开始，这样估计很多互联网公司都要倒闭了吧。</p>
<p>到 7 月份为止，每天的生活，基本就是从 8 楼爬下来，然后搭 BRT 去办公室，自己给自己定需求，一个人写代码，一个人吃饭，偶尔抬头看看这座城市在夕阳下的背影，然后一个人爬回 8 楼的房间里面睡觉。</p>
<p>和机器打交道太久，跟真实的人交流成了一件需要努力的事情。而学会和不同的人打交道成了一件不得不做的事情，每次约人聊事情，总要提前先准备一下写在纸上把思路演练一遍，尽管如此，每次结束聊天后总觉得有不尽人意的地方。在和认识或不认识的朋友聊了一圈后，终于遇到了W，在近一个月的反复沟通下，我们决定一起来做 C 大调。</p>
<p>8 月份开始就来到了 W 所在的城市-东莞，今天，也是待在东莞的一家书吧里面写这个文章。想到不用一个人来搞这个事情，事情又往前推动了一点，内心多了些许宽慰，心想只要把产品和内容完善一下，再把运营数据做的好看一点，接下来就可以启动融资了。</p>
<p>但事情并不顺利，W 是个音乐人，有几份工作，原本说好的基本全职变成了一个兼职的状态，没办法承担起内容的建设工作。团队完全没有运营经验，资金有限，招聘的运营人员也是刚毕业的，又一时找不到合适的运营合伙人，运营就成了瞎打乱撞的一件事情。</p>
<p>一个满带 bug 的团队是没办法走远的，融资的事情只能先放一边了，BP 就一直藏在硬盘里，到今天为止都没主动向任何一个投资人或者投资机构发出去过。</p>
<p>进退两难，特别痛苦，to be or not to be，总要有个决定，如果选择继续，那接下来应该怎么办？找了一些朋友来聊，这里特别感谢绍琛的指导，我非常敬佩的一个同龄校友，技术出身的创业者，先后创办了多家企业，目前致力于儿童编程教育领域。在和他聊完之后发现自己遇到的这点困难跟别人比起来根本不算什么，方向错了，想办法掉头咯，不懂的东西，又暂时找不到替代的人，那就自己先一点点学着做起来。</p>
<p>We’re gonna die… But not today.</p>
<p>我给自己定了 3 个月的期限，如果执行的结果不理想，那就先把这个事情先停下来。同时也在调整团队和发展的方向，lu起袖子来搞运营的事情，联系大V开课、搞活动、微信裂变、写文案… </p>
<p>时间在一天天过去，资金也在慢慢消耗殆尽… </p>
<p>每当觉得快要完蛋的时候，却总有一些没想到，鼓舞你再坚持一下：没想到直播分享课有这么多人来报名；没想到大V们都这么挺我们；没想到搞了个广州跨年音乐会人数会不到三天报名人数就爆满….</p>
<p>是你们给了我们前行的力量，谢谢你们！！</p>
<p><img src="/assets/2961547276022.jpg" alt=""></p>
<p>2018 这一年，身边的一些好友都逐渐成家，每次回家都能明显感觉到岁月在父母的脸上、发丝间留下的痕迹，对于时间的感知从未如此强烈，特别感谢亲人的支持，尤其是父亲，给了我莫大的鼓舞。</p>
<p>2019 年，没有意外会重新回到广州有个新的开始，这将是一段值得期待的旅程。翻了一下自己的时间清单，想完成的事情都还有在做，内心稍微笃定了一些。</p>
<p>世界这么大，一生太短，要记得浪啊~ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">叶大侠：C大调音乐网的Founder，一个热爱音乐和徒步旅行的代码er。</span><br><span class="line"></span><br><span class="line">持续寻找有兴趣一起搞事情的你~ 产品技术运营大牛/音乐达人</span><br><span class="line"></span><br><span class="line">#联系方式#</span><br><span class="line">公众号：音乐代码</span><br><span class="line">邮箱：yedaxia@foxmail.com</span><br><span class="line">个人主页：https://yedaxia.github.io/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;依我看，你所有的问题都可以通过多挣点钱来解决&lt;br&gt;– 生活大爆炸&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="个人成长" scheme="https://yedaxia.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>muse 2.7 乐谱脚本快速入门</title>
    <link href="https://yedaxia.github.io/Muse27-Quick-Start/"/>
    <id>https://yedaxia.github.io/Muse27-Quick-Start/</id>
    <published>2018-08-30T16:25:43.000Z</published>
    <updated>2019-01-10T16:08:19.575Z</updated>
    
    <content type="html"><![CDATA[<p>很难用的软件，但语法还是有可取的地方，仔细研究了一下，顺便出了个针对吉他谱和简谱的快速入门教程。</p>
<a id="more"></a>
<h1 id="软件下载和安装"><a href="#软件下载和安装" class="headerlink" title="软件下载和安装"></a>软件下载和安装</h1><ol>
<li><a href="https://pan.baidu.com/s/1Xnb6tKkkYD5OgWlESu8i8g" target="_blank" rel="noopener">下载</a>。</li>
<li>安装后把注册机放到安装目录下，然后双击打开注册机，复制注册码。</li>
</ol>
<p><img src="/assets/20180822230808.png" alt=""></p>
<ol start="3">
<li>打开软件【帮助】菜单 -》输入注册码，把获取到的注册码输入即可。</li>
</ol>
<p><img src="/assets/20180822230610.png" alt=""></p>
<blockquote>
<p>注意：这个软件 09 年就不维护了，杀毒软件会会提示木马，仅供研究，风险自担～</p>
</blockquote>
<p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T: 暖暖</span><br><span class="line">T: 演唱 梁静茹</span><br><span class="line">C: C大调音乐网</span><br><span class="line">M: 4/4</span><br><span class="line">Q: 60</span><br><span class="line">K: C</span><br><span class="line">L: 1/4</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822172644.png" alt=""></p>
<p><strong>解释：</strong></p>
<ol>
<li>T： 第一个标题是大标题，第二个 T 是小标题。</li>
<li>C：composer 的缩写，对应在右边的描述，可以有多个 C 。</li>
<li>M：meter 的缩写，节拍。</li>
<li>Q：每分钟有多少拍。</li>
<li>K：调号</li>
<li>L：默认拍长，就是音符单独出现的时候表示的拍长，如下代码和图：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[V:1]</span><br><span class="line">L: 1/4</span><br><span class="line">C</span><br><span class="line"></span><br><span class="line">[V:2]</span><br><span class="line">L: 1/8</span><br><span class="line">CD</span><br></pre></td></tr></table></figure>
<p><img src="/assets/20180822201209.png" alt=""></p>
<h1 id="音轨信息"><a href="#音轨信息" class="headerlink" title="音轨信息"></a>音轨信息</h1><p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V:1 style=tab clef=standardtab ins=24 vol=40 bracket=2</span><br><span class="line">V:2 style=jianpu ins=1 vol=100</span><br><span class="line">[V:1]</span><br><span class="line">ax</span><br><span class="line">[V:2]</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822202137.png" alt=""></p>
<p><strong>解释：</strong></p>
<p>知道 style=tab 代表六线谱，style=jianpu 代表简谱就可以了。[V:1] 表示下面写的是 V:1 style=tab 六线谱相关的音符信息，[V:2] 则对应的是简谱。</p>
<h1 id="音符"><a href="#音符" class="headerlink" title="音符"></a>音符</h1><p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T: 音名</span><br><span class="line">K:C</span><br><span class="line">M:4/4</span><br><span class="line">L:1/4</span><br><span class="line">V:1  style=tab</span><br><span class="line">V:2 style=jianpu</span><br><span class="line">[V: 1]</span><br><span class="line">a1b1c1d1f1 | axbxcxdxfx | [axbxcx][bxcxdx]V[axbxcx]U[bxcxdx] |z z/ z// |</span><br><span class="line">[V: 2]</span><br><span class="line">CDEFGAB | C,D,E,F,G,A,B, | C,,D,,E,,F,,G,,A,,B,, | cdefgab | c&apos;d&apos;e&apos;f&apos;g&apos;a&apos;b&apos; | ^C=C_C z |</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822204038.png" alt=""></p>
<p><strong>tab （六线）谱音符解释：</strong></p>
<ol>
<li>a 代表最下面的弦（吉他最细的弦），f 代表最上面的弦，abcdef 依次类推；</li>
<li>a1 表示 a 弦的 1 品；ax 表示 a 弦是 x 符号。</li>
<li>[axbxcx] 表示同时多个音。</li>
<li>V 和 U 是修饰符，表示下扫弦和上扫弦，更多修饰符看【修饰符】小节。</li>
<li>z 是休止符，同简谱</li>
</ol>
<p><strong>简谱音符解释：</strong></p>
<ol>
<li>CDEFGAB 对应 1234567。</li>
<li>cdefgab 对应高八度的 1234567。</li>
<li>C, 下标表示低八度，C‘ 上标表示高八度。</li>
<li>^ 是升半音，= 是还原音，_ 是降半音。</li>
</ol>
<h1 id="音长"><a href="#音长" class="headerlink" title="音长"></a>音长</h1><p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">T: 节奏型</span><br><span class="line">K:C</span><br><span class="line">M:4/4</span><br><span class="line">L:1/4</span><br><span class="line">V:1  style=tab</span><br><span class="line">V:2 style=jianpu</span><br><span class="line">[V: 1]</span><br><span class="line">ax*4|ax*2b1*2|ex/[axbxcx/]ex/[axbxcx/] | ex[axbxcx/][axbxcx/]ex [axbxcx] | [axex/]cx//bx// dx//ax//cx//bx// |  ex//bx/cx// ex//bx/cx// |</span><br><span class="line">ex/&gt;dx/ [cxbxax/]d/ ex/&lt;dx/  | ex/cx//&gt;dx// ex/cx//&lt;dx// | </span><br><span class="line">ex/ [cxbxax] [cxbxax/] [cxbxax] [cxbxax] | ex// [cxbxax]  ex// |</span><br><span class="line">(3axbxcx(3ax/bx/cx/|</span><br><span class="line"></span><br><span class="line">[V: 2]</span><br><span class="line">C4 | D3B | D2B2 | DB3 | C/D/E/F/ | C/D//F// C//D//F/ | D// C F// | C&gt;F C/&gt;F/ | C// F/ D//  C/D/ | (3CDE (3C/D/E/ |</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822212046.png" alt=""></p>
<p><strong>解释：</strong></p>
<ol>
<li>tab 谱 <em> 号表示乘以默认时长（L: 1/4），比如 ax</em>4 表示全音符；简谱则不需要加 * 号，C4 表示全音符。</li>
<li>/ 表示默认时长的一半，比如 ax/ 表示 半拍，ax// 表示 1/4 拍。</li>
<li>>表示付点音符，为前音符时长的 1.5 倍，&lt; 则表示后音符为1.5倍。</li>
<li>(3 表示三连音。</li>
</ol>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">T: 装饰音和倚音</span><br><span class="line">K:C</span><br><span class="line">M:4/4</span><br><span class="line">L:1/4</span><br><span class="line">V:1  style=tab</span><br><span class="line">V:2 style=jianpu</span><br><span class="line">[V: 1]</span><br><span class="line">V[axbxcx]V[bxcx]U[axbxcxdx]U[bxcxdx] | A[axbxcx]A[bxcx]B[axbxcxdx]B[bxcxdx]  |.[axbxcx] &apos;[axbxcx] T[axbxcx] H[axbxcx] | S[axbxcx]  PV[axbxcx]  S|</span><br><span class="line">[V:2]</span><br><span class="line">.C &apos;D TD HE | &#123;C&#125;C SG S|</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822213355.png" alt=""></p>
<p><strong>解释：</strong></p>
<table>
<thead>
<tr>
<th>语法符号</th>
<th>对应字段</th>
<th>意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>staccato</td>
<td>断音、切音</td>
</tr>
<tr>
<td>V</td>
<td>upstrum</td>
<td>上扫弦</td>
</tr>
<tr>
<td>U</td>
<td>downstrum</td>
<td>下扫弦</td>
</tr>
<tr>
<td>A</td>
<td>uparpeggio</td>
<td>上琶音</td>
</tr>
<tr>
<td>B</td>
<td>downarpeggio</td>
<td>下琶音</td>
</tr>
<tr>
<td>‘</td>
<td>accent</td>
<td>加重</td>
</tr>
<tr>
<td>T</td>
<td>trill</td>
<td>颤音</td>
</tr>
<tr>
<td>H</td>
<td>fermata</td>
<td>延长音</td>
</tr>
<tr>
<td>P</td>
<td>pralltriller</td>
<td>延长</td>
</tr>
</tbody>
</table>
<h1 id="连音"><a href="#连音" class="headerlink" title="连音"></a>连音</h1><p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T: 连音线用例</span><br><span class="line">K:C</span><br><span class="line">M:4/4</span><br><span class="line">L:1/4</span><br><span class="line">V:1  style=tab</span><br><span class="line">V:2 style=jianpu</span><br><span class="line">[V: 1]</span><br><span class="line">a1-a1[c1-d1]c1 | a1-S-a2-P-a3-H-a4 | [ax-bxcx]a4 [axbxcx]-S-a4 | (axbx)cx(ax |</span><br><span class="line">ax)bxcxdx | axbx(cxdx | axax)cxdx | ((axbx)cx)dx |  (ax(bxcx))((dx | ax)bx)cxax |</span><br><span class="line">[V: 2]</span><br><span class="line">CC-C-C | (CC)(CC) | CC(CC |  CC)CC |  ((CC)C)C |  (C(CC))C | CC(C(C | C)C)CC |</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822213844.png" alt=""></p>
<p><strong>解释：</strong></p>
<ol>
<li>相邻的可以用 - 来连接。</li>
<li>相邻两个音连接技巧支持 S（滑弦）、H（击弦）、P（勾弦）。</li>
<li>() 可以用于不相邻的连接。</li>
</ol>
<h1 id="小节线和重复段"><a href="#小节线和重复段" class="headerlink" title="小节线和重复段"></a>小节线和重复段</h1><p><strong>脚本代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T: 小节线</span><br><span class="line">K:C</span><br><span class="line">M:4/4</span><br><span class="line">L:1/4</span><br><span class="line">V:1  style=tab</span><br><span class="line">[V: 1]</span><br><span class="line">a1b1c1d1f1 | axbxcxdxfx :| axbxcxdxfx |: axbxcxdxfx :: axbxcxdxfx |</span><br><span class="line">axbxcxdxfx ]| axbxcxdxfx |[  axbxcxdxfx |1 axbxcxdxfx |2 axbxcxdxfx ||</span><br></pre></td></tr></table></figure>
<p><strong>对应的效果图：</strong></p>
<p><img src="/assets/20180822215041.png" alt=""></p>
<p><strong>解释：</strong></p>
<p><img src="/assets/tab_abc_line_bar.png?imageView2/0/w/400" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很难用的软件，但语法还是有可取的地方，仔细研究了一下，顺便出了个针对吉他谱和简谱的快速入门教程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="音乐编程" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记一次邮件采访</title>
    <link href="https://yedaxia.github.io/osc-email-interview/"/>
    <id>https://yedaxia.github.io/osc-email-interview/</id>
    <published>2018-08-08T14:25:46.000Z</published>
    <updated>2018-08-08T14:59:05.817Z</updated>
    
    <content type="html"><![CDATA[<p>有幸收到开源中国的一次邮件采访，乱七八糟写了一大堆，这里是原来的回答，在这里记录一下，整理后发表的文章点击<a href="https://www.oschina.net/question/3820517_2284423" target="_blank" rel="noopener">这里</a>。</p>
<a id="more"></a>
<blockquote>
<p>看到您开源了不少项目，结合开源经历简单介绍一下其中几个比较酷的吧。</p>
</blockquote>
<p>其实大部分开源出来的东西都是在工作中‘顺便’提取出来的小东西，我简单介绍其中几个的背景，希望对大家有所启发。</p>
<p><strong>1.<a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">JApiDocs</a>: </strong></p>
<p>这个是基于 Java 语言特点实现的一个 API 接口文档生成工具，可以让大家在写代码的同时就写好了接口文档。在决定开始做这个工具的时候之前，我主要还是在负责 Android 端的开发工作，开发组里面的后端程序员们总是代码写好之后，然后才手工地把接口信息再一次写在相关文档上面，如果接口有改动，他们代码和文档都得改。这种协作方式会有几个问题，一是前端程序员要等接口文档，二是如果接口设计不合理后面大家又要改。从后端的接口到接口文档到客户端的请求，其实可以合并成一步的工作，因为它们需要的信息都是等价的。我知道后台他们用的是 Java 语言，基于对 Java 语言的了解，我开始动手设计这个东西，那时候还是挺忙的，这个小工具基本都是挤时间来完成的，前后大概花了 2 周时间，刚做好的时候蛮激动的，点击运行就哗啦啦把该有的东西一次性输出，后端程序员们很快就爱上了这个小工具。最初的版本其实蛮简单的，而且也只是考虑了 <a href="https://www.playframework.com/" target="_blank" rel="noopener">playframework</a> 这个开发框架。后来打算开源出去，所以才进一步去完善，目前也是我最多人关注的一个开源项目。</p>
<p><strong>2.<a href="https://github.com/YeDaxia/SQLiteUtils" target="_blank" rel="noopener">SQLiteUtils</a>: </strong></p>
<p>这是对 Android SQLite 数据库操作接口的一个很简单的封装，尽管没什么人关注，不过它是我第一个整理出来的开源作品。刚工作接触到的第一个项目很多业务都是在基于本地数据数据库实现的，因此整个项目代码到处都是拼接的 sql 代码，看起来很头疼，这时突然想起大学的时候用过 Hibernate，虽然没有仔细研究过它的具体原理，但它大概长什么样子我是有印象的，因此想到能不能做个类似的东西，那以后的日子就好过很多了。那会刚毕业，没什么经验，也不知道有其他更好的库，就这样瞎捣鼓起来，最后实现的效果居然还不错，而且总的开发时间并没有花很多，后面都赚回来了。虽然现在看来是个还是一个比较幼稚的东西，但当时正是因为这个做这个事情得到了不少锻炼。</p>
<p>分享和互助，这是程序员这个群体最纯粹的精神之一。和大部分程序员一样，我也是面向 github 和谷歌编程的。当你感受到社区的帮助，你也会慢慢开始反馈社区。</p>
<p>有些人觉得开源是一件很难的事情，我觉得一方面要结合现有的工作，在你能掌控的时间内想办法做的更好一些，而不仅仅是完成任务；另外一方面是要有‘偷懒’的思维，是否有很多枯燥或重复性的工作？这些能不能通过花点时间写个程序搞定？</p>
<p>当你做的东西得到了同行的认可，除了能让你收获满满的成就感，也有助于你的职业生涯。另外你把自己的思考和成果和别人分享的时候，你就会对自己做的东西有更高的要求了，它会进一步去促使你提升自己。</p>
<blockquote>
<p>您开源了多个项目，包括自己的博客，其中比较多的是关于音乐的内容，您也创办了个人音乐网站，目前还在研发音乐产品，似乎音乐和开发是您生活中占比较大的东西。您是一名程序员，但是却对音乐有较深的想法与能力，音乐和程序这本来是两个完全不相关的东西，那么最开始你是怎么在音乐与程序两者之间游走的，怎么将两者结合起来的呢？（比如有些人是从小喜欢吉他之类的乐器，后来从事开发。。。介绍一下你的这个历程，包括开发音乐相关的开源项目的背景啥的）</p>
</blockquote>
<p>我是在农村长大的，小时候，我堂哥偶尔会坐在他家门口用一把破烂的吉他弹一些 beyond 的歌，那时候我就觉得一个个音符从他指尖流淌出来是一件很奇妙的事情。初中的时候有部队来我们那训练，寄住在我家，有一天，一个兵哥晚饭后，拿把吉他坐在门口的小凳子上，弹起了《丁香花》，那时候觉得特别动听，我问他能不能教我一下，可惜还没开始学部队就离开了村子。上高中后生活变得特别枯燥，幸运的是，班上有几个会玩吉他的，最开心的事情，莫过于偶尔能和三两好友在拥挤的宿舍里弹琴唱歌了，那时候经常就是盯着看谁的琴空闲，就问他能不能借回来玩一下，当你热爱一件事情，就像玩游戏一样，你总能找到法子来学着玩起来。</p>
<p>大学读的是计算机专业，在此之前对计算机的了解几乎为零，除了小时候沉迷过一段时间的小霸王，我完美地错过了《大话西游》《泡泡堂》… 直到现在也没有玩过一个网络游戏，成了青春时期的一大憾事。幸好有吉他可以打发一下闲暇时光，我上大学后买了第一把琴，那时候也知道可以在互联网找乐谱了，通过了 youtube 知道了郑成河（韩国一个有名的指弹吉他手），通过他知道了 fingerstyle，知道原来吉他还能这样玩。那时候学了很多曲子，很奇妙的是一些乐理的东西尽管没人教自己也慢慢懂了。</p>
<p>毕业后，工作赚到一点钱我就跑到香港给自己买了把马丁（一个美国吉他品牌），但遗憾的是，一方面工作的忙碌，一方面是到了遇到了瓶颈，跟着别人写好的乐谱来弹没什么动力，又找不到人教，所以在很长的时间里都没怎么玩了，以至于琴弦都生了铜锈。后来一次搬家回到大学城，在住的附近有一家音乐主题的咖啡馆，我有空就过去听别人弹，偶尔自己也上去玩一下，慢慢又认识了一些玩音乐的朋友，有时候大家兴致来了也会去路演（卖唱），就这样又重新拿起了沉睡已久的吉他，并尝试去自学一些乐理的东西。后面在壹心理（一家心理学互联网平台）任职的时候，我和另外一个同事在里面创立了个吉他俱乐部，中午的休息时候我们经常聚在一个小会议室里面玩琴，虽然后来不在那里了，但我们这群人也还是会经常聚在一起玩，也不断有一些新的小伙伴加进来。</p>
<p>上一次工作是在一个游戏创业公司里面当移动端的技术负责人，虽然在技术层面可以把工作做好，但因为骨子里面根本没有游戏基因，缺乏内驱的动力，除了赚钱也找不到什么理由了，所以当在利益层面没有得到预期的满足时，我便不愿意这样混日子下去了。在离开这家公司后，我慢慢地开始深入去思考自己未来的方向，在选择方向上我的逻辑是很简单的：如果选一件能坚持五年，十年甚至更久的事情，那么我必须热爱这个事情。我的答案就是做一件和音乐有关的事情，音乐人这个方向离现实可能还有点远，而编程是我熟悉的一个领域，那很自然就想到用技术去为音乐去做点事情了。</p>
<p>如果只是有想法，那愿意和你聊的人可能都很少，如果你真的把一些东西做出来了，那很多人都会去仔细倾听。所以我首先是做了个找搜谱引擎，它通过爬虫定期的抓取国内外的乐谱网站，目前是国内最全的乐谱数据库了。然后通过网络和朋友圈，不断和相关领域的人进行交流，一方面是进一步了解音乐这个行业，试图去找到一个突破口，另一方面是寻找潜在志同道合的小伙伴。技术方面也没落下，继续在音频、midi和乐谱渲染等和音乐相关的核心技术去不断探索，做了一些小工具。没想到一晃半年就过去了，正当我在为找不到一个合适的合伙人发愁的时候，甚至一度很焦虑：钱花光了人都还没找到怎么办？所幸的是，两个月前一个炎热的下午，在母校图书馆的咖啡馆里，本来只是想让约的音乐人朋友帮忙做点内容，结果对方抛过来的第一句话却是：我想加入！我们一拍即合，决定一起来做这个事情。我们总的愿景是：让音乐爱好者花更低的成本学会一门乐器，让音乐老师能赚更多的钱。未来，我们会朝着这个方向慢慢去努力。</p>
<p>对了，我们正在努力上线一个让音乐爱好者有眼前一亮的产品，可以关注我们的网站 <a href="https://www.52cmajor.com/" target="_blank" rel="noopener">C大调音乐网</a>，目前在寻求融资，我们非常欢迎志同道合的你前来勾搭，有机会我们可以一起干一票大的。</p>
<blockquote>
<p>从你的 timelist  上看，其中有学习音乐、学习感兴趣的技术、国外旅游、写文章、扒吉他谱、游泳、跑步、读书等项目，再结合您一系列经历来看，你是很佛系的程序员，而我们也疑惑，这些活动应该是占用了一些时间的，那你是开发工作很轻松吗？介绍一下你的开发工作（现在好像是在创业？那讲讲自己之前的开发工作）。这些活动和开发工作你又是怎么安排时间和精力的呢？</p>
</blockquote>
<p>我之前的工作基本都是在做 Android 应用开发，所在公司基本还是有双休的，工作日一般都会有一定的加班，也有偶尔空闲和提前搞定的情况，就会早点下班。为了节省一些时间，我一般会住在离公司的骑行 10 分钟范围内，早上有时跑个步再去上班都是来的及的。我经常鼓励身边的程序员去写技术文章，去总结和输出，这样无论对知识和影响力的积累都是有好处的。文章我一般都是结合现有的工作去写的，这样也会促使我把工作做的更好，写技术文章其实蛮耗时间的，有时候我会用周末的一整天时间，有时候会分开多个章节，有空就填一点，我不逼迫自己要定期产出，而是等到真的有东西可写的时候再去动笔。</p>
<p>15 年开始，我逐渐喜欢上了一项比较 cool 的运动：徒步，一开始是跟着一些周末出行的俱乐部去一些地方，比如麦理浩径、武功山；再后面离职后，我决定独自背包出去看看这个世界，这次出走了差不多 1 个月的时间，时间是 12 月份，看了很多风景，遇见了很多有趣的人。其中印象比较深刻的有在香格里拉梅里雪山下的雨崩村遇到 60 岁的韩国老爷爷，独自一人，我陪他在雨崩走了两天，他说明年还要去四川看看；在四川牛背山碰到一个还没毕业的江南姑娘，她纤细的身姿，和接下来要将近 8 个小时的体力消耗是联想不到一块的，她走的很慢，半路我们还遭遇了暴雪的袭击，第二天下山后我们一起去了海螺沟冰川，在分别时，我问她你接下来去哪，她说会去大理一边做义工，一边继续旅行。有时候我会想，从大爆炸到地球的形成到生命的出现到现在的我，有 99.99…% 的概率是不应该出现的，但奇迹就这样发生了，只有好好把握好时光，浪费在美好的事物上，才配得上这份弥足珍贵的幸运。</p>
<p>曾经在一个<a href="https://paulrosen.net/about-me/" target="_blank" rel="noopener">博客</a>上看到这么一段话：</p>
<blockquote>
<p>Find three hobbies you love: one to make you money, one to keep you in shape, and one to be creative.<br>（找到你热爱的三个爱好：一个可以帮你赚钱，一个让你保持健康，一个让你有创造力。）</p>
</blockquote>
<p>我很喜欢这段话，这个理念和我的想法不谋而合，编程可以让我赚到钱，游泳和跑步则是很好的减压方式，创造力是我欠缺的部分，我很期待音乐可以帮我补上这一部分。</p>
<p>如果你经常觉得自己很忙，没时间做自己想做的一些事情，你不妨按照程序员的习惯，按照“性能优化”的思路：先给自己的时间使用打一小段时间的“log”，看时间都花在哪里了，接着看哪里有优化的空间，尤其着重耗时比较多的地方和循环次数比较多的地方。我很早就培养了这样一个意识，如果差不多的一件事情反复出现，那就应该用工具或一段程序去让它自动化。一个优秀的程序员，应该去不断打磨和优化自己的技能、工具和流程，这样就会逐步变得高效起来，也能省出更多属于自己的时间。</p>
<blockquote>
<p>现在有些企业觉得不加班的程序员不是他们要的（没有表现出工作量很大的程序员），他们想要的是完全接受 996，甚至能够进一步为公司加班的人，巴不得人家 24 小时工作（虽然表面上是说不提倡加班文化），结合你的经历与周边程序员以及他们公司的制度，分享一下你眼中看到的当国内国外程序员的工作与生活现状吧。你是怎么看待生活与工作的关系的呢？</p>
</blockquote>
<p>国内确实比较少没有加班的互联网企业，我了解到的身边的同行包括我自己经历过的公司，无论大小，基本都会有加班。我觉得加班是没有问题的，但是要提前信息告知，比如入职的时候要清楚地告知加班的情况，待遇给到位了，对方是否能接受这种上班的强度，那就看个人的选择了。我个人是不喜欢无缘由的加班的，尤其那种明明没什么工作，下班后却没一个人敢走，你要自己先走，领导就觉得你工作没饱和，这种氛围下只会生产出越来越多的老油条和低效程序员，以工作时间和代码行数来衡量程序员的工作，这是很愚蠢的评估方式。另外作为程序员自己，也要学会往内看，比如对任务的完成时间评估不够合理？代码质量太差，bug多，可扩展性差，应对需求变化的能力差等，经常也是因为一些技术债务问题导致的加班。</p>
<p>我是属于基本可以自主掌控自己的工作生活的人，我觉得很大部分原因和我的家庭是有关系的，我家人基本对我是一个信任和支持的态度，不会给我压力和过多干预。我觉得工作最终还是回归到自己喜欢的一件事情上为好，尽管前面你为了积累资金、人脉而做一些自己并不喜欢的事情。毕竟工作会占用你生命的大半时间啊，一生都只为赚钱的工作那得留下多少遗憾。我觉得保持对这个世界的好奇心，去探索她，去感知她，这点很重要。</p>
<blockquote>
<p>如今不少媒体喜欢炒作焦虑，什么“第一批90后已经老了”、“第一批90后已经出家了”、“第一批90后已经离婚了”、“年薪200万的人被裁掉了，月薪5000的你该怎么办？”、“你以为你是在学习，其实你只是在感动自己”、“**你都还不知道，你已经 out 了”、“你的安全感，正在毁掉你”……其实生活压力确实存在，但是这些文章现象级地出现，让原本已经身心俱疲的程序员承担更多压力。这些能够产生焦虑的信息不同于打鸡血，如果把打鸡血看作谆谆善诱，那么这些焦虑信息就好比来自成功者的嘲讽。你觉得这些东西我们应该接受吗，程序员如何在这样一种氛围中保持该有的态度？</p>
</blockquote>
<p>我是 90 年出生的，我和我的同龄人应该就是他们说的第一批 90 后了吧，除了那个出家的，其他的还没怎么了解，哈哈，吓得脱离群众的我果断 google 了一下。看了几篇文章，说不定这些文章就是 90 后自己写的。我觉得程序员是一个很优秀的群体，普遍进取心和学习意愿都很强，不过技术的进化也是日新月异的，也有人认为程序员是碗青春饭，这也不是不无道理的，如果你停止学习，那不久的将来被替代也是很有可能的。我觉得有一定危机感是好事，但也没有必要过度焦虑，很多新的技术它都是有延续性和共性的，你的经验和积累的知识会让你更快地掌握新的东西。</p>
<p>另外一点我想谈的是如职业生涯中能有一次机会能站在浪潮之巅，也许就能完成资本的积累，而程序员是其中最有希望一个群体，持续学习和精进，等待机会的到来，这就是我们该做的事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有幸收到开源中国的一次邮件采访，乱七八糟写了一大堆，这里是原来的回答，在这里记录一下，整理后发表的文章点击&lt;a href=&quot;https://www.oschina.net/question/3820517_2284423&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人成长" scheme="https://yedaxia.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Muse 乐谱数据结构解析</title>
    <link href="https://yedaxia.github.io/muse-tab-structure/"/>
    <id>https://yedaxia.github.io/muse-tab-structure/</id>
    <published>2018-07-21T02:05:02.000Z</published>
    <updated>2019-01-10T16:08:19.589Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章提出了一个支持 muse 乐谱语法的数据结构，是基于abc 乐谱数据结构的基础上进行部分优化，并支持了 tab 谱[六线谱、四线谱]、简谱。</p>
<a id="more"></a>
<h2 id="描述信息"><a href="#描述信息" class="headerlink" title="描述信息"></a>描述信息</h2><p><strong>主标题：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：T: 单身情歌 （第一个）</span><br><span class="line">字段：metaText.title</span><br></pre></td></tr></table></figure>
<p><strong>副标题：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：T: 演唱 林志炫（第n个,n 大于等于2）</span><br><span class="line">字段：metaText.subtitle</span><br></pre></td></tr></table></figure></p>
<p><strong>作者：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：C: 陈耀川</span><br><span class="line">字段：metaText.composer</span><br></pre></td></tr></table></figure></p>
<p>当有多个 C 出现的时候，在<code>composer</code>用换行符分隔。</p>
<h2 id="调号、拍号和速度"><a href="#调号、拍号和速度" class="headerlink" title="调号、拍号和速度"></a>调号、拍号和速度</h2><p><strong>调号:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：K: C</span><br><span class="line">字段：key</span><br><span class="line">&#123;</span><br><span class="line">    acc:&apos;&apos;, //升降调 （#/b)</span><br><span class="line">    accidentals:[],// 忽略</span><br><span class="line">    mode:&apos;&apos;, // 忽略</span><br><span class="line">    root:&apos;C&apos; //调名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>拍号：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法：M: 3/8</span><br><span class="line">字段：meter</span><br><span class="line">&#123;</span><br><span class="line">    type: &apos;specified&apos;, //可忽略</span><br><span class="line">    value: [</span><br><span class="line">        &#123;num:&apos;3&apos;,den:&apos;8&apos;&#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>速度：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：Q: 1/4=120 &quot;Slowly&quot;</span><br><span class="line">字段：metaText.tempo</span><br><span class="line">&#123;</span><br><span class="line">    bpm: 120, </span><br><span class="line">    duration:[0.25], </span><br><span class="line">    postString: &apos;Slowly&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面表示 一分钟 120 个 1/4 拍。</p>
<h2 id="音符、和弦"><a href="#音符、和弦" class="headerlink" title="音符、和弦"></a>音符、和弦</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">字段：staffs[i].voices[i]:</span><br><span class="line">&#123;</span><br><span class="line">    chord: [&#123;</span><br><span class="line">        name: &quot;C/E&quot;, //和弦名称，查询和弦表</span><br><span class="line">        position: &apos;&apos;// 忽略</span><br><span class="line">    &#125;], </span><br><span class="line">    duration: 0.0625, //音长</span><br><span class="line">    el_type: &apos;note&apos;,</span><br><span class="line">    pitches: [&#123;</span><br><span class="line">        fret:1, //品数，或者&apos;x&apos;</span><br><span class="line">        string: 5, //第几弦:&#123;a:1, b:2, c:3, d:4, e:5, f:6&#125;</span><br><span class="line">        pitch: 2 //简谱用到</span><br><span class="line">        accidental: &apos;sharp&apos; //升半音：sharp, 降半音：flat</span><br><span class="line">    &#125;], //多个的时候表示和声，需要在同一线上绘制，可能是扫弦。</span><br><span class="line">    decoration: [&apos;staccato&apos;,&apos;downstrum&apos;]//装饰音</span><br><span class="line">    gracenotes: &#123;&#125;,//倚音</span><br><span class="line">    rest: &#123;//休止符</span><br><span class="line">       type: rest/multimeasure</span><br><span class="line">    &#125;,</span><br><span class="line">    startTie: &#123;//延长音开始</span><br><span class="line">        //&#123;&apos;S&apos;:&apos;shift slide&apos;, &apos;H&apos;:&apos;hammer on&apos;, &apos;P&apos;:&apos;pull off&apos;&#125;</span><br><span class="line">        effect: &quot;shift slide&quot; //滑音等一下效果音会有这个字段，</span><br><span class="line">    &#125;</span><br><span class="line">    endTie: //延长音结束</span><br><span class="line">    startSlur: //连音</span><br><span class="line">    endSlur: //连音</span><br><span class="line">    startTriplet: 3 // n连音开始标识位，表示 3 连音</span><br><span class="line">    endTriplet: // n连音结束标识位</span><br><span class="line">    tripletMultiplier: //连音音长</span><br><span class="line">    lyric:[&#123; //歌词, 可能有多行歌词</span><br><span class="line">        divider:&apos;&apos;,</span><br><span class="line">        syllable:&apos;&apos;, </span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>tie 表示的是同相同的延音</li>
<li>slur 则是两个不同音高的连音</li>
<li>triplet 表示3连音，n连音等，在音长上面比较特殊</li>
</ul>
<h3 id="音高"><a href="#音高" class="headerlink" title="音高"></a>音高</h3><p><strong>四/六线谱</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     fret:1, //品数，或者&apos;x&apos;</span><br><span class="line">     string: 5, //第几弦:&#123;a:1, b:2, c:3, d:4, e:5, f:6&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>a: 是谱线最上面的一根，以此类推。</li>
<li>如果是扫弦或者琶音的话，那只要关注最上面和最下面的弦就可以了。</li>
</ul>
<p><strong>简谱</strong></p>
<p>在 muse 中，中央 <code>C</code> 代表 <code>1</code>, 小 <code>c</code> 代表高八度的 <code>1</code>，<code>C&#39;</code> 则表示小八度的 <code>1</code>，<code>C&#39;&#39;</code> 则必<code>C&#39;</code>更小，<code>c&#39;</code> 则是比 <code>c</code> 高八度。</p>
<p>如下按音从低到高，其顺序和五线谱的表示法是一致的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C&apos;&apos;, C&apos;, C, c, c&apos;, c&apos;&apos;</span><br></pre></td></tr></table></figure>
<p>对应在<code>pitch</code>字段中的值是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11&#125;</span><br><span class="line"></span><br><span class="line">C&apos; = C(0) - 7 = -7</span><br><span class="line">c&apos; = c(7) + 7 = 14 </span><br><span class="line">依此类推...</span><br></pre></td></tr></table></figure>
<p><strong>变音记号</strong></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^b1</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>语法记号</th>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>sharp</td>
<td>表示升半音</td>
</tr>
<tr>
<td><code>=</code></td>
<td>natural</td>
<td>表示还原音</td>
</tr>
<tr>
<td><code>_</code></td>
<td>flat</td>
<td>降半音</td>
</tr>
<tr>
<td><code>^^</code></td>
<td>double sharp</td>
<td>升全音(暂不考虑)</td>
</tr>
</tbody>
</table>
<h3 id="音长"><a href="#音长" class="headerlink" title="音长"></a>音长</h3><p>默认音长：<code>L: 1/4</code></p>
<p>语法：</p>
<ul>
<li><code>/</code>、<code>/2</code>  默认音长一半0.5</li>
<li><code>//</code> 默认音长 1/4（0.25）</li>
<li><code>2</code>  默认音长 2 倍</li>
<li><code>&gt;</code>  前付点 3/2 倍，后减音长 1/2 </li>
<li><code>&lt;</code>  后付点，前减音长</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弹唱谱例子：c1/, c1/2, cx//, a2*2</span><br><span class="line">简谱例子：A/, C// ,c1</span><br></pre></td></tr></table></figure>
<p>弹唱谱需要表示把位，所以需要用<code>/</code>表示倍减，<code>*</code>表示倍增。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">音长计算的值 = 默认音长 * 音长的倍数，</span><br></pre></td></tr></table></figure>
<h3 id="和弦图"><a href="#和弦图" class="headerlink" title="和弦图"></a>和弦图</h3><p>所有和弦包括默认的和弦在和弦表字段<code>gchords</code>当中，如果不存在在和弦表中，则绘制和弦名称即可。</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：&lt;和弦名称&gt;=&lt;起始品数&gt;;&lt;第n弦品位&gt;(手指),&lt;第n-1弦品位&gt;(手指),...&lt;第1弦品位&gt;(手指)</span><br><span class="line"></span><br><span class="line">例子： %%gchord C=1;X,3,2,0,1,0</span><br></pre></td></tr></table></figure>
<p>其中手指是可选的。<code>X</code>代表和弦外音。</p>
<p><strong>数据结构：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &quot;C&quot;, //和弦名</span><br><span class="line">    chord: [[1, 0],[2, 1], [3, 0], [4, 2], [5,3], [6, &quot;X&quot;]], //[&lt;第几品&gt;:&lt;手指&gt;]，数组的长度是弦的数量，数组下标按弦从上往下（从粗到细）， x 代表和弦外音</span><br><span class="line">    position: 3, //开始品数</span><br><span class="line">    bars: [&#123;from_string: 5, to_string: 1, fret: 1&#125;] //大横按，from_string: 开始弦， to_string：结束弦，fret：品数(相对position)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>bars</code> 是扩展字段，没有声明不需要绘制；position 没有声明也不需要绘制，</p>
<h3 id="装饰音"><a href="#装饰音" class="headerlink" title="装饰音"></a>装饰音</h3><p>用法：在音符前添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例子：u[b1*2-e3/]</span><br></pre></td></tr></table></figure>
<p>下面是可能出现的装饰音：</p>
<table>
<thead>
<tr>
<th>语法符号</th>
<th>对应字段</th>
<th>意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>staccato</td>
<td>断音、切音</td>
</tr>
<tr>
<td>V</td>
<td>upstrum</td>
<td>上扫弦</td>
</tr>
<tr>
<td>U</td>
<td>downstrum</td>
<td>下扫弦</td>
</tr>
<tr>
<td>A</td>
<td>uparpeggio</td>
<td>上琶音</td>
</tr>
<tr>
<td>B</td>
<td>downarpeggio</td>
<td>下琶音</td>
</tr>
<tr>
<td>‘</td>
<td>accent</td>
<td>加重</td>
</tr>
<tr>
<td>T</td>
<td>trill</td>
<td>颤音</td>
</tr>
<tr>
<td>H</td>
<td>fermata</td>
<td>延长音</td>
</tr>
<tr>
<td>P</td>
<td>pralltriller</td>
<td>延长</td>
</tr>
</tbody>
</table>
<h3 id="倚音："><a href="#倚音：" class="headerlink" title="倚音："></a>倚音：</h3><p>用法：在音符前添加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例子：&#123;a1b1&#125;[c2//d2//]</span><br></pre></td></tr></table></figure></p>
<p>数据结构：和音符是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    accidental:&apos;sharp&apos;,</span><br><span class="line">    duration: 0.5,</span><br><span class="line">    el_type:&apos;note&apos;,</span><br><span class="line">    pitch: 12,</span><br><span class="line">    fret:1,</span><br><span class="line">    string:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二连音、三连音和n连音"><a href="#二连音、三连音和n连音" class="headerlink" title="二连音、三连音和n连音"></a>二连音、三连音和n连音</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(n</span><br><span class="line">简单连音例子：(2aC1</span><br><span class="line">(p:q:r</span><br><span class="line">复杂连音例子：(3:2:4G2A2B1</span><br></pre></td></tr></table></figure></p>
<p>对应数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">startTriplet: 开始标识位</span><br><span class="line">endTriplet:  结束标识位</span><br><span class="line">tripletMultiplier: 每个音音长 绘制不需要关心这个？</span><br></pre></td></tr></table></figure></p>
<h3 id="休止符"><a href="#休止符" class="headerlink" title="休止符"></a>休止符</h3><p>表示符号：<code>z</code> 和 <code>Z</code>，音长方面表示和音符是一样的。</p>
<ul>
<li>z : rest 休止符</li>
<li>Z : multimeasure 多小节休止符，暂时不用考虑</li>
</ul>
<h3 id="连音线-滑弦、敲弦、勾弦"><a href="#连音线-滑弦、敲弦、勾弦" class="headerlink" title="连音线(滑弦、敲弦、勾弦)"></a>连音线(滑弦、敲弦、勾弦)</h3><p>语法：</p>
<p>tie : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ex-ex 、[^b1*2-e3/]-S-[b2*5/2e4*5/2]</span><br></pre></td></tr></table></figure>
<p>slur: 可以嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a3b2d2)b1)</span><br></pre></td></tr></table></figure>
<h2 id="小节线和重复线"><a href="#小节线和重复线" class="headerlink" title="小节线和重复线"></a>小节线和重复线</h2><p>数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    el_type:&apos;bar&apos;,</span><br><span class="line">    type: &apos;bar_thin&apos; //bar类型</span><br><span class="line">    startEnding: &apos;&apos; //重复段落数字和开始标志</span><br><span class="line">    endEnding: &apos;&apos;  //重复结束标志</span><br><span class="line">    barNumber: &apos;&apos; //忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/tab_abc_line_bar.png?imageView2/0/w/400" alt="abc bar"></p>
<h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><p>英文歌词以空格断字，中文单字断字。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>数据表示</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td> -</td>
<td></td>
<td>英文单词断开 </td>
</tr>
<tr>
<td> *</td>
<td></td>
<td>跳过一个音符</td>
</tr>
<tr>
<td> ~</td>
<td></td>
<td>链接连个字，对齐同个音符</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://abcjs.net/" target="_blank" rel="noopener">abcjs</a>: javascript for rendering abc music notation.</p>
</li>
<li><p>muse 2.7 制谱软件帮助文档。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章提出了一个支持 muse 乐谱语法的数据结构，是基于abc 乐谱数据结构的基础上进行部分优化，并支持了 tab 谱[六线谱、四线谱]、简谱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐编程" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的时间清单</title>
    <link href="https://yedaxia.github.io/My-timelist-at-2018/"/>
    <id>https://yedaxia.github.io/My-timelist-at-2018/</id>
    <published>2018-07-16T15:23:33.000Z</published>
    <updated>2018-07-17T00:57:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>这个清单是受到采铜老师的书《精进: 如何成为一个很厉害的人》的启发，非常佩服作者的剖析和思考力，值得仔细研读的一本书；此外，这还是一本实操手册。想来想去，还是觉得记录在博客上比较靠谱。</p>
<a id="more"></a>
<p>当你说了一些话，出于自恋的需求，你会爱上自己说的话，并让事情朝着这个方向去发展，证明你是对的，你是好的。</p>
<h2 id="未来五年想做的事情："><a href="#未来五年想做的事情：" class="headerlink" title="未来五年想做的事情："></a>未来五年想做的事情：</h2><ol>
<li>做一个有一定影响力的产品。</li>
<li>找到满意的另一半，进入一段高质量的亲密关系。</li>
<li>学会即兴伴奏和简单的作曲编曲。</li>
<li>学习并初步掌握一门感兴趣的技术，比如机器学习。</li>
<li>每年去一个不同的国家徒步旅行。</li>
</ol>
<h2 id="每个月需要完成的事情"><a href="#每个月需要完成的事情" class="headerlink" title="每个月需要完成的事情"></a>每个月需要完成的事情</h2><ol>
<li>写一篇文章。</li>
<li>扒一首歌，并进行简单的分析，录制一个视频。</li>
<li>认识一个新朋友或拜访一个朋友。</li>
</ol>
<h2 id="每周让自己放松下来的事情"><a href="#每周让自己放松下来的事情" class="headerlink" title="每周让自己放松下来的事情"></a>每周让自己放松下来的事情</h2><ol>
<li>游泳2次，跑步2次。</li>
<li>周末下午，找个安静的地方看书。</li>
</ol>
<h2 id="一项长期爱好"><a href="#一项长期爱好" class="headerlink" title="一项长期爱好"></a>一项长期爱好</h2><ol>
<li>玩音乐，找到合理的训练方法，每天上班前或者下班后可以有 30 分钟左右的时间练习。</li>
</ol>
<h2 id="需要降低频率的行为"><a href="#需要降低频率的行为" class="headerlink" title="需要降低频率的行为"></a>需要降低频率的行为</h2><ol>
<li>减少打开手机的次数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个清单是受到采铜老师的书《精进: 如何成为一个很厉害的人》的启发，非常佩服作者的剖析和思考力，值得仔细研读的一本书；此外，这还是一本实操手册。想来想去，还是觉得记录在博客上比较靠谱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人成长" scheme="https://yedaxia.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Android 实现边听伴奏边K歌探究</title>
    <link href="https://yedaxia.github.io/Android-Sync-Audio-Record-With-Play/"/>
    <id>https://yedaxia.github.io/Android-Sync-Audio-Record-With-Play/</id>
    <published>2018-03-17T17:17:50.000Z</published>
    <updated>2019-01-10T16:08:19.587Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章可以为你提供一个解决录音和播放的同步的思路，而且解决了声音从手机传输到耳机上的延时的问题。</p>
<a id="more"></a>
<p>你需要有一些关于音频的基本认识，如果你还不是很了解，建议先阅读前面两篇文章。</p>
<ol>
<li><a href="http://yedaxia.me/Android-Audio-Basic/" target="_blank" rel="noopener">写给小白的音频认识基础</a></li>
<li><a href="http://yedaxia.me/Android-A-Good-MixAudioMethod/" target="_blank" rel="noopener">Android上一种效果奇好的混音方法介绍</a></li>
</ol>
<h1 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h1><p>音乐中只有一种声音有时候很单薄的，我们经常希望把不同的声音加在一起，但是在录制的时候我们需要严格同步起来，把两种声音的时差控制在听觉允许的范围内，才可能获得我们想要的结果。另外一点，在录制的时候，为了不把播放的声音和人声或者器乐声混到一块，通常都需要录制者带着耳机边听边录。</p>
<p>为了实现最终两个或者多个声音能非常好的契合到一起，除了要解决录音和播放的同步，还需要考虑到声音从手机传输到耳机上的延时。这个场景除了会出现在一些比较专业的音乐软件上，常用的 K 歌软件也不可避免会遇到这个问题。</p>
<h1 id="一线希望：MediaSyncEvent"><a href="#一线希望：MediaSyncEvent" class="headerlink" title="一线希望：MediaSyncEvent?"></a>一线希望：MediaSyncEvent?</h1><p>先抛出结论：并不能解决问题～</p>
<p>肯定先从 SDK 入手，发现 <code>AudioRecord</code> 里面有个方法 <code>startRecording(MediaSyncEvent syncEvent)</code> , 再看了一遍文档， 仿佛在黑暗中看到了一丝光亮。</p>
<blockquote>
<p>The MediaSyncEvent class defines events that can be used to synchronize playback or capture * actions between different players and recorders.</p>
</blockquote>
<p>然而对于它的使用资料实在太少，stackoverflow 上有个提问是 0 回答：<a href="https://stackoverflow.com/questions/40198791/does-anyone-know-how-to-use-the-mediasyncevent-to-sync-playback-and-capture" target="_blank" rel="noopener">这里</a>。翻了 Google 很久，最终在官方的 CTS (Compatibility Test Suite) 中找到了它的身影：在 <a href="https://android.googlesource.com/platform/cts/+/b36beae93fd074e908d74acca86940186066c2a0/tests/tests/media/src/android/media/cts/AudioRecordTest.java" target="_blank" rel="noopener">AudioRecordTest</a> 的<code>testSynchronizedRecord</code>方法中。这里顺便提一下，这些单元测试是非常好实打实的官方学习资料，如果苦于找不到答案的时候，不妨来这里找找看。</p>
<p>研究完<code>testSynchronizedRecord</code>我们回来看看<code>MediaSyncEvent</code>它究竟是用来干嘛的？</p>
<p><code>MediaSycEvent</code> 可以通过 <code>MediaSyncEvent.createEvent()</code> 进行构造，它支持两种事件类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * No sync event specified. When used with a synchronized playback or capture method, the</span><br><span class="line"> * behavior is equivalent to calling the corresponding non synchronized method.</span><br><span class="line"> */</span><br><span class="line">public static final int SYNC_EVENT_NONE = AudioSystem.SYNC_EVENT_NONE;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The corresponding action is triggered only when the presentation is completed</span><br><span class="line"> * (meaning the media has been presented to the user) on the specified session.</span><br><span class="line"> * A synchronization of this type requires a source audio session ID to be set via</span><br><span class="line"> * &#123;@link #setAudioSessionId(int) method.</span><br><span class="line"> */</span><br><span class="line">public static final int SYNC_EVENT_PRESENTATION_COMPLETE = AudioSystem.SYNC_EVENT_PRESENTATION_COMPLETE;</span><br></pre></td></tr></table></figure>
<p>其实就只有一种，<code>SYNC_EVENT_NONE</code> 就相当于没有同步事件，常规的 <code>AudioRecord.startRecording()</code> 方法就是用的这个参数。从<a href="https://android.googlesource.com/platform/cts/+/b36beae93fd074e908d74acca86940186066c2a0/tests/tests/media/src/android/media/cts/AudioRecordTest.java" target="_blank" rel="noopener">AudioRecordTest.testSynchronizedRecord</a> 的测试用例中可以得知<code>SYNC_EVENT_PRESENTATION_COMPLETE</code>的作用其实是等<code>AudioTrack</code>播放完的瞬间才触发<code>AudioRecord</code>的录音，这明显和我们的需求是不通的，没想明白在哪些场景会有这个需求，Google 要专门提供这个一个参数，如果有想法的朋友可以给我留言。</p>
<h1 id="CyclicBarrier-来帮忙"><a href="#CyclicBarrier-来帮忙" class="headerlink" title="CyclicBarrier 来帮忙"></a>CyclicBarrier 来帮忙</h1><p>此路不通之后，我们需要另辟蹊径。在运动员比赛前，我们需要先让大家在同一线上等待，直到看到信号发出再一起出发。在这里，我们也需要让 <code>AudioTrack</code> 和 <code>AudioRecord</code> 先在同一起跑线上等着，然后一起出发，各奔东西。Java 世界里面的<code>CyclicBarrier</code>就很合适做这件事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play 和 record 两个同步线程</span></span><br><span class="line">CyclicBarrier recordBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">AudioTrack audioTrack;</span><br><span class="line">AudioRecord audioRecord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UI Thread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    recordBarrier.reset();</span><br><span class="line">    audioTrack.play();</span><br><span class="line">    audioRecord.startRecording();</span><br><span class="line">    <span class="keyword">new</span> RecordThread().start();</span><br><span class="line">    <span class="keyword">new</span> PlayThread().start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//等play线程开始写的时候read</span></span><br><span class="line">        recordBarrier.await();</span><br><span class="line">        audioRecord.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//等reacord线程开始读的时候write</span></span><br><span class="line">        recordBarrier.await();</span><br><span class="line">        audioTrack.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面通过<code>CyclicBarrier</code>让 <code>AudioTrack</code>的 <code>write</code> 和 <code>AudioRecord</code> 的 <code>read</code> 在同一起跑线上，似乎事情已经解决了，然而并没有。虽然你开始往耳机<code>write</code>数据，但是耳机接收到信号真正发出声音还要一段时间。</p>
<h1 id="处理录音延时问题"><a href="#处理录音延时问题" class="headerlink" title="处理录音延时问题"></a>处理录音延时问题</h1><p>我们回到用户真实的使用场景中，来看看问题是如何发生的？</p>
<p><img src="/assets/WX20180318-10194.png?imageView2/0/w/400" alt="录音延时"></p>
<p>播放源是真实的数据源，比如位于 1ms 的伴奏数据块从写入<code>AudioTrack</code>开始到耳机播放可能已经是 100ms 后的事情了，而用户这个时候才开始录入自己的声音，这里还可能会有从设备开始采集声音到缓冲区的一个延时，如果是使用蓝牙耳机的话，那延时的问题就会更加突出了。</p>
<p>我们来感受一下延时的情况，在咖啡馆录的音，杂音比较多，但是不难听出来录音是比原来的声音要延迟了。</p>
<audio controls="controls" height="40" width="100"><br>  <source src="/assets/audio-sync-test-1.mp3"><br></audio>

<p>看下声波图：</p>
<p><img src="/assets/WX20180318-125342.png?imageView2/0/w/400" alt="延迟声波图"></p>
<p><strong>解决方案：</strong></p>
<p>当录音和播放开始之后，它们就会在同一时域中平行演绎，根据延时的特点，我们不难得出：</p>
<blockquote>
<p>录音时长 = 延迟时长 + 播放时长 + 额外时长(播放完之后的自由录音)</p>
</blockquote>
<p>只要我们能知道延迟的时长，在读取录音数据的时候，我们只要截取掉 <code>AudioRecord</code> 前面的延迟数据就可以让问题得到解决了。那怎么才能知道应该截掉多少个 byte 的数据呢？在这里我想到了一个巧妙的解决方法，给大家分享一下思路。</p>
<p>从上面的节拍器的声波图我们可以看到，波峰对应的就是<code>哒</code>的那一声，录音音轨和节拍器音轨上的波峰差就是我们想知道的<code>延迟时长</code>。根据这个特点，我们可以设计出获取这个<code>延迟时长</code>的一个思路：</p>
<ol>
<li>让用户带上耳机，根据固定节奏的节拍器(要有一定时间间隔)声音进行录音，简单的<code>啦..啦..啦..</code>就好。</li>
<li>根据获取到的录音数据和原始的节拍器声音进行比较, 我取的是 8 个波峰区间数据进行比较，如果延迟误差都在一个小范围内，那就认为是正确的。</li>
</ol>
<p><img src="/assets/WX20180318-133238.png?imageView/0/w/400" alt=""></p>
<p>具体的算法大概如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ANALYZE_BEAT_LEN = 8</span></span><br><span class="line"><span class="keyword">int</span>[] maxPositions = <span class="keyword">new</span> <span class="keyword">int</span>[ANALYZE_BEAT_LEN];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i != maxPositions.length; i++)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] segBytes = getSegBytes(); <span class="comment">//获取一拍时长的数据</span></span><br><span class="line">    maxPositions[i] = getMaxSamplePos(segBytes);<span class="comment">// 获取拍中波峰所在的大致位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按小到大排序</span></span><br><span class="line">Arrays.sort(maxPositions);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中间一半的值，如果平均值误差在 10 毫秒内，就认为是正确的</span></span><br><span class="line"><span class="keyword">int</span> sampleTotalValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sampleLen = ANALYZE_BEAT_LEN / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] sampleValues = <span class="keyword">new</span> <span class="keyword">int</span>[sampleLen];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> beginIndex = sampleLen / <span class="number">2</span>, i=<span class="number">0</span>; i != sampleLen; i++)&#123;</span><br><span class="line">    sampleValues[i] = maxPositions[ i + beginIndex];</span><br><span class="line">    sampleTotalValue += sampleValues[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> averSampleValue = sampleTotalValue / sampleLen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isValid = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> sampleValue : sampleValues)&#123;</span><br><span class="line">    <span class="comment">//errorRangeByteLen : 10 毫秒的 byte 长度</span></span><br><span class="line">    <span class="keyword">if</span>(Math.abs(averSampleValue - sampleValue) &gt; errorRangeByteLen)&#123;</span><br><span class="line">        isValid = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">    stopPlay = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">int</span> result = averSampleValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p>波形图：</p>
<p><img src="/assets/20180318-141515-adjust.png?imageView2/0/w/400" alt=""></p>
<p>声音结果：</p>
<audio controls="controls" height="40" width="100"><br>  <source src="/assets/audio-sync-test-2.mp3"><br></audio>

<p>调整之后情况就改善多了，听觉上基本感受不到延迟了。但是这样会给用户带来一些不方便，换耳机的时候需要重新调整。个人的认知实在有限，虽然这可能是个有效的方法，但肯定不是最佳的做法，同时好奇像唱吧这种软件是如何处理的？欢迎大牛们交流一下想法～</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p>无线音频的延时问题：<a href="http://www.memchina.cn/News/9733.html" target="_blank" rel="noopener">http://www.memchina.cn/News/9733.html</a></p>
</li>
<li><p><a href="https://android.googlesource.com/platform/cts/+/b36beae93fd074e908d74acca86940186066c2a0/tests/tests/media/src/android/media/cts/AudioRecordTest.java" target="_blank" rel="noopener">MediaSyncEvent TestCase: </a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章可以为你提供一个解决录音和播放的同步的思路，而且解决了声音从手机传输到耳机上的延时的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音频处理" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
      <category term="Android" scheme="https://yedaxia.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>一个人如何像一支乐队一样练琴 | 工具推荐</title>
    <link href="https://yedaxia.github.io/How-To-Play-Music-Like-A-Bank/"/>
    <id>https://yedaxia.github.io/How-To-Play-Music-Like-A-Bank/</id>
    <published>2018-03-14T08:38:54.000Z</published>
    <updated>2018-03-14T08:47:14.331Z</updated>
    
    <content type="html"><![CDATA[<p>开发了一个小工具，为你的音乐学习之路赋能。</p>
<a id="more"></a>
<h1 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h1><p>近段时间想学习一下即兴伴奏，但是平时有很难找到人一起练习，又没找到合适的辅助工具，所以就做了这个小工具。它的名字改来改去，最后取了个：声音笔记+。记录声音，并且声音和另一个声音相加。嗯，大概就是这个含义。</p>
<h1 id="它可以做什么？"><a href="#它可以做什么？" class="headerlink" title="它可以做什么？"></a>它可以做什么？</h1><p>有了它的辅助，一个人也可以是一只乐队了。是进行多重合奏练习，即兴练习的利器；另外顺带了一个字节级精准的节拍器，练琴必备。</p>
<h1 id="声明和反馈"><a href="#声明和反馈" class="headerlink" title="声明和反馈"></a>声明和反馈</h1><p>目前功能还很原始，但我相信一直对于苦苦寻找一个合适相关工具的你肯定会有相见恨晚的感觉。一个好用的音频处理的应用开发是一件有挑战的事，需要你的支持，发现有什么问题或者建议，请反馈给我（微信号：yedaxia2017），我们可以一起让它变得更好用一些。</p>
<p>App 没有携带任何的后台程序，不会浪费你设备额外的电量。收集 bug 和统计使用了腾讯 Bugly 服务，除此之外没有任何的第三方服务在里面，根据 bugly 的声明，我想应该可以放心跟你说，我们没有收集你相关的任何隐私信息。</p>
<p>以下是 bugly 的声明：</p>
<blockquote>
<p>Bugly收集的信息都是为了更真实地为开发者还原Crash场景服务的，并不涉及用户隐私信息：<br>Crash环境：Crash信息及线程堆栈，ROM/RAM/SD卡容量、网络/语言等状态<br>App信息：包名、版本、所属进程名<br>设备信息：IMEI等设备识别，用于判断Crash设备统计。</p>
</blockquote>
<h1 id="如何获取？"><a href="#如何获取？" class="headerlink" title="如何获取？"></a>如何获取？</h1><p>目前只在 Google Play 上架了，国内市场还在审核。点击<a href="http://52cmajor.com/app/musicNote" target="_blank" rel="noopener">这里</a>跳到下载页面，微信内是要跳到外部浏览器才能下载的。Google Play 是需要付费的，国内用户也无法进行访问下载，从原文进去的下载是可以获得免费版的。</p>
<p>我录了个很丑的视频，不知道你们看不看的懂～</p>
<iframe frameborder="0" width="400" height="250" src="https://v.qq.com/iframe/player.html?vid=z0567cqxyfr&tiny=0&auto=0" allowfullscreen></iframe>

<p>使用是一种支持，欢迎你分享给身边需要的朋友。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发了一个小工具，为你的音乐学习之路赋能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Android上一种效果奇好的混音方法介绍</title>
    <link href="https://yedaxia.github.io/Android-A-Good-MixAudioMethod/"/>
    <id>https://yedaxia.github.io/Android-A-Good-MixAudioMethod/</id>
    <published>2018-03-10T17:11:45.000Z</published>
    <updated>2019-01-10T16:08:19.590Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对几种音频混音的方法进行详细的介绍和比较，读完之后你应该可以对混音有个基本的认识，针对不同情形知道应该采用哪种具体的处理方法了。</p>
<a id="more"></a>
<p>如果对音频的一些基础知识还不是很了解的建议先去阅读一下上一篇文章：<a href="http://yedaxia.me/Android-Audio-Basic/" target="_blank" rel="noopener">写给小白的音频认识基础
</a>。</p>
<h1 id="混音的原理"><a href="#混音的原理" class="headerlink" title="混音的原理"></a>混音的原理</h1><p>音频混音的原理: 空气中声波的叠加等价于量化的语音信号的叠加。</p>
<p><img src="/assets/darcy_blog_mix_audio_theory.jpg" alt="混音原理图"></p>
<p>这句话可能有点拗口，我们从程序员的角度去观察就不难理解了。下图是两条音轨的数据，将每个通道的值做线性叠加后的值就是混音的结果了。比如音轨A和音轨B的叠加，<code>A.1</code> 表示 A 音轨的 1 通道的值 <code>AB03</code> , <code>B.1</code> 表示 B 音轨的 1 通道的值 <code>1122</code> , 结果是 <code>bc25</code>，然后按照低位在前的方式排列，在合成音轨中就是 <code>25bc</code>，这里的表示都是 16 进制的。</p>
<p><img src="/assets/digital-audio-mix-theory.png?imageView2/0/w/500" alt="音轨合成图"></p>
<p>直接加起来就可以了？事情如果这么简单就好了。音频设备支持的采样精度肯定都是有限的，一般为 8 位或者 16 位，大一些的为 32 位。在音轨数据叠加的过程中，肯定会导致溢出的问题。为了解决这个问题，人们找了不少的办法。这里我主要介绍几种我用过的，并给出相关代码实现和最终的混音效果对比结果。</p>
<h1 id="线性叠加平均"><a href="#线性叠加平均" class="headerlink" title="线性叠加平均"></a>线性叠加平均</h1><p>这种办法的原理非常简单粗暴，也不会引入噪音。原理就是把不同音轨的通道值叠加之后取平均值，这样就不会有溢出的问题了。但是会带来的后果就是某一路或几路音量特别小那么整个混音结果的音量会被拉低。</p>
<p>以下的的单路音轨的音频参数我们假定为采样频率一致，通道数一致，通道采样精度统一为 16 位。</p>
<p>其中参数 <code>bMulRoadAudios</code> 的一维表示的是音轨数，二维表示该音轨的音频数据。</p>
<p><strong>Java 代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] mixRawAudioBytes(<span class="keyword">byte</span>[][] bMulRoadAudios) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bMulRoadAudios == <span class="keyword">null</span> || bMulRoadAudios.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] realMixAudio = bMulRoadAudios[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(realMixAudio == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> row = bMulRoadAudios.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//单路音轨</span></span><br><span class="line">            <span class="keyword">if</span> (bMulRoadAudios.length == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> realMixAudio;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不同轨道长度要一致，不够要补齐</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> rw = <span class="number">0</span>; rw &lt; bMulRoadAudios.length; ++rw) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bMulRoadAudios[rw] == <span class="keyword">null</span> || bMulRoadAudios[rw].length != realMixAudio.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 精度为 16位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> col = realMixAudio.length / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">short</span>[][] sMulRoadAudios = <span class="keyword">new</span> <span class="keyword">short</span>[row][col];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; row; ++r) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; col; ++c) &#123;</span><br><span class="line">                    sMulRoadAudios[r][c] = (<span class="keyword">short</span>) ((bMulRoadAudios[r][c * <span class="number">2</span>] &amp; <span class="number">0xff</span>) | (bMulRoadAudios[r][c * <span class="number">2</span> + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">short</span>[] sMixAudio = <span class="keyword">new</span> <span class="keyword">short</span>[col];</span><br><span class="line">            <span class="keyword">int</span> mixVal;</span><br><span class="line">            <span class="keyword">int</span> sr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sc = <span class="number">0</span>; sc &lt; col; ++sc) &#123;</span><br><span class="line">                mixVal = <span class="number">0</span>;</span><br><span class="line">                sr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; sr &lt; row; ++sr) &#123;</span><br><span class="line">                    mixVal += sMulRoadAudios[sr][sc];</span><br><span class="line">                &#125;</span><br><span class="line">                sMixAudio[sc] = (<span class="keyword">short</span>) (mixVal / row);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (sr = <span class="number">0</span>; sr &lt; col; ++sr) &#123;</span><br><span class="line">                realMixAudio[sr * <span class="number">2</span>] = (<span class="keyword">byte</span>) (sMixAudio[sr] &amp; <span class="number">0x00FF</span>);</span><br><span class="line">                realMixAudio[sr * <span class="number">2</span> + <span class="number">1</span>] = (<span class="keyword">byte</span>) ((sMixAudio[sr] &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> realMixAudio;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="自适应混音"><a href="#自适应混音" class="headerlink" title="自适应混音"></a>自适应混音</h1><p>参与混音的多路音频信号自身的特点,以它们自身的比例作为权重,从而决定它们在合成后的输出中所占的比重。具体的原理可以参考这篇论文：<a href="http://www.jos.org.cn/1000-9825/16/108.pdf" target="_blank" rel="noopener">快速实时自适应混音方案研究</a>。这种方法对于音轨路数比较多的情况应该会比上面的平均法要好，但是可能会引入噪音。</p>
<p><strong>Java 代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">byte</span>[] mixRawAudioBytes(<span class="keyword">byte</span>[][] bMulRoadAudios) &#123;</span><br><span class="line">     <span class="comment">//简化检查代码</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 精度为 16位</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">int</span> col = realMixAudio.length / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">short</span>[][] sMulRoadAudios = <span class="keyword">new</span> <span class="keyword">short</span>[row][col];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; row; ++r) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; col; ++c) &#123;</span><br><span class="line">             sMulRoadAudios[r][c] = (<span class="keyword">short</span>) ((bMulRoadAudios[r][c * <span class="number">2</span>] &amp; <span class="number">0xff</span>) | (bMulRoadAudios[r][c * <span class="number">2</span> + <span class="number">1</span>] &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">short</span>[] sMixAudio = <span class="keyword">new</span> <span class="keyword">short</span>[col];</span><br><span class="line">     <span class="keyword">int</span> sr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">double</span> wValue;</span><br><span class="line">     <span class="keyword">double</span> absSumVal;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> sc = <span class="number">0</span>; sc &lt; col; ++sc) &#123;</span><br><span class="line">         sr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         wValue = <span class="number">0</span>;</span><br><span class="line">         absSumVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (; sr &lt; row; ++sr) &#123;</span><br><span class="line">             wValue += Math.pow(sMulRoadAudios[sr][sc], <span class="number">2</span>) * Math.signum(sMulRoadAudios[sr][sc]);</span><br><span class="line">             absSumVal += Math.abs(sMulRoadAudios[sr][sc]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         sMixAudio[sc] = absSumVal == <span class="number">0</span> ? <span class="number">0</span> : (<span class="keyword">short</span>) (wValue / absSumVal);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (sr = <span class="number">0</span>; sr &lt; col; ++sr) &#123;</span><br><span class="line">         realMixAudio[sr * <span class="number">2</span>] = (<span class="keyword">byte</span>) (sMixAudio[sr] &amp; <span class="number">0x00FF</span>);</span><br><span class="line">         realMixAudio[sr * <span class="number">2</span> + <span class="number">1</span>] = (<span class="keyword">byte</span>) ((sMixAudio[sr] &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> realMixAudio;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="多通道混音"><a href="#多通道混音" class="headerlink" title="多通道混音"></a>多通道混音</h1><p>在实际开发中，我发现上面的两种方法都不能达到满意的效果。一方面是和音乐相关，对音频质量要求比较高；另外一方面是通过手机录音，效果肯定不会太好。不知道从哪里冒出来的灵感，为什么不试着把不同的音轨数据塞到不同的通道上，让声音从不同的喇叭上同时发出，这样也可以达到混音的效果啊！而且不会有音频数据损失的问题，能很完美地呈现原来的声音。</p>
<p>于是我开始查了一下 Android 对多通道的支持情况，对应代码可以在<code>android.media.AudioFormat</code>中查看,结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_FRONT_LEFT = <span class="number">0x4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_FRONT_RIGHT = <span class="number">0x8</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_FRONT_CENTER = <span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_LOW_FREQUENCY = <span class="number">0x20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_BACK_LEFT = <span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_BACK_RIGHT = <span class="number">0x80</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_FRONT_LEFT_OF_CENTER = <span class="number">0x100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_FRONT_RIGHT_OF_CENTER = <span class="number">0x200</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_BACK_CENTER = <span class="number">0x400</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_SIDE_LEFT =         <span class="number">0x800</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHANNEL_OUT_SIDE_RIGHT =       <span class="number">0x1000</span>;</span><br></pre></td></tr></table></figure>
<p>一共支持 10 个通道，对于我的情况来说是完全够用了。我们的耳机一般只有左右声道，那些更多通道的支持是 Android 系统内部通过软件算法模拟实现的，至于具体如何实现的，我也没有深入了解，在这里我们知道这回事就行了。我们平时所熟知的立体声，5.1 环绕等就是上面那些通道的组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> CHANNEL_OUT_MONO = CHANNEL_OUT_FRONT_LEFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CHANNEL_OUT_STEREO = (CHANNEL_OUT_FRONT_LEFT | CHANNEL_OUT_FRONT_RIGHT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CHANNEL_OUT_5POINT1 = (CHANNEL_OUT_FRONT_LEFT | CHANNEL_OUT_FRONT_RIGHT |</span><br><span class="line">           CHANNEL_OUT_FRONT_CENTER | CHANNEL_OUT_LOW_FREQUENCY | CHANNEL_OUT_BACK_LEFT | CHANNEL_OUT_BACK_RIGHT);</span><br></pre></td></tr></table></figure>
<p>知道原理之后，实现起来非常简单，下面是具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] mixRawAudioBytes(<span class="keyword">byte</span>[][] bMulRoadAudios) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> roadLen = bMulRoadAudios.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单路音轨</span></span><br><span class="line">    <span class="keyword">if</span> (roadLen == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> bMulRoadAudios[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxRoadByteLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">byte</span>[] audioData : bMulRoadAudios)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxRoadByteLen &lt; audioData.length)&#123;</span><br><span class="line">            maxRoadByteLen = audioData.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] resultMixData = <span class="keyword">new</span> <span class="keyword">byte</span>[maxRoadByteLen * roadLen];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != maxRoadByteLen; i = i + <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r != roadLen; r++)&#123;</span><br><span class="line">            resultMixData[i * roadLen + <span class="number">2</span> * r] = bMulRoadAudios[r][i];</span><br><span class="line">            resultMixData[i * roadLen + <span class="number">2</span> * r + <span class="number">1</span>] = bMulRoadAudios[r][i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMixData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结果比较"><a href="#结果比较" class="headerlink" title="结果比较"></a>结果比较</h1><p>线性叠加平均法虽然看起来很简单，但是在音轨数量比较少的时候取得的效果可能会比复杂的自适应混音法要出色。</p>
<p>自适应混音法比较合适音轨数量比较多的情况，但是可能会引入一些噪音。</p>
<p>多通道混音虽然看起来很完美，但是产生的文件大小是数倍于其他的处理方法。</p>
<p>没有银弹，还是要根据自己的应用场景来选择，多试一下。</p>
<p>下面是我录的两路音轨：</p>
<ul>
<li><p>音轨一：</p>
<audio controls="controls" height="40" width="100"><br><source src="/assets/feb3bfa6-0984-4fa6-a406-228bf5ecb6ad.wav" type="audio/wav"><br></audio>
</li>
<li><p>音轨二：</p>
<audio controls="controls" height="40" width="100"><br><source src="/assets/8ac76e2a-792d-4716-907e-63fe602b54f1.wav"><br></audio>
</li>
<li><p>线性叠加平均法：</p>
<audio controls="controls" height="40" width="100"><br><source src="/assets/Average-audio.wav"><br></audio>
</li>
<li><p>自适应混音法：</p>
<audio controls="controls" height="40" width="100"><br><source src="/assets/AutoAlign-audio.wav"><br></audio>
</li>
<li><p>多通道混音：</p>
<audio controls="controls" height="40" width="100"><br><source src="/assets/ChannelAlign-audio.wav"><br></audio>

</li>
</ul>
<h1 id="采样频率、采样精度和通道数不同的情况如何处理？"><a href="#采样频率、采样精度和通道数不同的情况如何处理？" class="headerlink" title="采样频率、采样精度和通道数不同的情况如何处理？"></a>采样频率、采样精度和通道数不同的情况如何处理？</h1><p>不同采样频率需要算法进行重新采样处理，让所有音轨在同一采样率下进行混音，这个比较复杂，等有机会再写篇文章介绍。</p>
<p>采样精度不同比较好处理，向上取精度较高的作为基准即可，高位补0；如果是需要取向下精度作为基准的，那么就要把最大通道值和基准最大值取个倍数，把数值都降到最大基准数以下，然后把低位移除。</p>
<p>通道数不同的情况也和精度不同的情况相似处理。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://www.jos.org.cn/1000-9825/16/108.pdf" target="_blank" rel="noopener">多媒体会议中的快速实时自适应混音方案研究</a> </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对几种音频混音的方法进行详细的介绍和比较，读完之后你应该可以对混音有个基本的认识，针对不同情形知道应该采用哪种具体的处理方法了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音频处理" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
      <category term="Android" scheme="https://yedaxia.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>写给小白的音频认识基础</title>
    <link href="https://yedaxia.github.io/Android-Audio-Basic/"/>
    <id>https://yedaxia.github.io/Android-Audio-Basic/</id>
    <published>2018-03-06T14:24:24.000Z</published>
    <updated>2019-01-10T16:08:19.582Z</updated>
    
    <content type="html"><![CDATA[<p>虽然从初中物理就认识声音是一种波，但在真正用代码去表达的时候我才建立了深刻的认识。</p>
<a id="more"></a>
<h1 id="初识音频"><a href="#初识音频" class="headerlink" title="初识音频"></a>初识音频</h1><p>从初中物理上我们就学到，声音是一种波。计算机只能处理离散的信号，通过收集足够多的离散的信号，来不断逼近波形，这个过程我们叫做采样。怎么样才能更好的还原声音信息呢？这里很自然引出两个概念了。</p>
<p><img src="/assets/darcy_blog_sound_wav.png?imageView2/0/w/400" alt="声音波形图"></p>
<p><strong>采样频率(Sample Rate)</strong>：每秒采集声音的数量，它用赫兹(Hz)来表示。</p>
<p>采样率越高越靠近原声音的波形，常见的采样率有以下几种：</p>
<ul>
<li>8khz：电话等使用，对于记录人声已经足够使用。</li>
<li>22.05khz：广播使用频率。</li>
<li>44.1kb：音频CD。</li>
<li>48khz：DVD、数字电视中使用。</li>
<li>96khz-192khz：DVD-Audio、蓝光高清等使用。</li>
</ul>
<p><strong>采样精度(Bit Depth)</strong>: 它表示每次采样的精度，位数越多，能记录的范围就越大。</p>
<p>采样精度常用范围为8bit-32bit，而CD中一般都使用16bit。</p>
<p>把声音记录下来之后，通过喇叭的震动把波再还给空气传到你的耳朵就完成了这个完美的循环了。但是富有创造力的人类不会限制于此就结束了，很快人们发现，当把不同的声音传递到不同的喇叭的时候，竟然会惊奇地让声音变得有<strong>空间感</strong>了，即时是同一个声音，也比单个通道能获得更好的体验，于是就出现了什么立体声，5.1 环绕等看起来很高大上的东西。所以，音频又多了一个东西：</p>
<p><strong>声音通道(Channel)</strong>: 你知道每个通道存储的声音会从其中的一个喇叭出来就好了，不过可以通过算法的模拟来让没有那么多喇叭也能出来类似的效果。</p>
<p>有了声音通道，乐队在录音的时候就可以每个人插一条音轨了，然后每一个声音可以写到不同的通道里面，当然，实际录音当然都是后期混音而成的。下面介绍的其中一个混音算法会用到声音通道这个特性。</p>
<p>最后再介绍一个大家经常看到的概念：</p>
<p><strong>比特率(bps [bits per second])</strong>: 其实看单位就很容易知道它要表达的意思了，就是每秒钟要播放多少 bit 的数据。公式一目了然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比特率 = 采样率 × 采样深度 × 通道。</span><br></pre></td></tr></table></figure></p>
<p>比如 采样率 = 44100，采样深度 = 16，通道 = 2 的音频的的比特率就是 44100 <em> 16 </em> 2 = 1411200 bps。</p>
<p>一般来说，比特率越高，音频质量越好。要注意一些比特率的换算不是 1024 作为一个级别换算的哈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,000 bps	= 【1 kbps】 =	1,000 bit/s</span><br><span class="line">1,000,000 bps	= 【1 Mbps】 =	1,000,000 bit/s	</span><br><span class="line">1,000,000,000 bps	= 【1 Gbps】 =	1,000,000,000 bit/s</span><br></pre></td></tr></table></figure>
<h1 id="音频在计算机中的表示"><a href="#音频在计算机中的表示" class="headerlink" title="音频在计算机中的表示"></a>音频在计算机中的表示</h1><p>我们来看一下真实音频在计算机中究竟是怎样的表示状态，这里指的是原始的数据表示，而非编码(Mp3,Acc等)后的表示，平时我们看到的<code>.wav</code>后缀的音频，把前面 44 个字节用于记录采样率、通道等的头部信息去掉后就是就是原始的音频数据了。</p>
<p><img src="/assets/darcy_blog_wav_format.gif" alt="WAV表示图"></p>
<p>在理解了上面的概念之后，我们再来看这张图。对于文件头部信息我们就不详细介绍了，不影响我们理解介绍的混音处理方式，需要了解的可以点击<a href="http://soundfile.sapp.org/doc/WaveFormat/" target="_blank" rel="noopener">这里</a>。</p>
<p>我们抽取其中的一个采样来看，这里我加多了一个通道，便于大家理解通道的存储位置。</p>
<p><img src="/assets/98udab8shdhvy2ncidbo.png?imageView2/0/w/390" alt="音频采样图"></p>
<p>不难理解，这个采样中有三个通道，每通道采样精度是 16 比特。每个采样值的排序是 Little-Endian 低位在前的方式，比如通道 1 的采样值就是 <code>AB03</code>, 每个采样值的大小表示的是幅度信息。</p>
<p>好了，先介绍到这里，希望对你有帮助，如果文章有理解错误的地方，请给我留言指出，感谢你的阅读，下一篇将会介绍有关音频混音的相关知识。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://soundfile.sapp.org/doc/WaveFormat/" target="_blank" rel="noopener">WAV文件格式</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E7%8E%87" target="_blank" rel="noopener">维基百科-比特率</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然从初中物理就认识声音是一种波，但在真正用代码去表达的时候我才建立了深刻的认识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音频处理" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>VexTab介绍 - 一种即时可视的web乐谱语言 | 译文</title>
    <link href="https://yedaxia.github.io/VexTab-Introdution/"/>
    <id>https://yedaxia.github.io/VexTab-Introdution/</id>
    <published>2018-02-02T16:26:15.000Z</published>
    <updated>2018-02-03T03:58:50.494Z</updated>
    
    <content type="html"><![CDATA[<p>VexTab 是一种用于书写音乐的语言，你只需要花非常少的时间学习一下，就可以用它来创建，编辑和分享非常好看的五线谱和六线谱了。和 ASCII 谱的设计目标为易于阅读不一样，VexTab 是为了可方便书写而诞生的。</p>
<a id="more"></a>
<p>英文原文：<a href="http://www.vexflow.com/vextab/tutorial.html" target="_blank" rel="noopener">vextab tutorial</a><br>在线体验：<a href="http://52cmajor.com/tab/editor" target="_blank" rel="noopener">vextab 编辑器</a></p>
<h2 id="什么是-VexTab"><a href="#什么是-VexTab" class="headerlink" title="什么是 VexTab ?"></a>什么是 VexTab ?</h2><p>VexTab 是一种用于书写音乐的语言，你只需要花非常少的时间学习一下，就可以用它来创建，编辑和分享非常好看的五线谱和六线谱了。和 ASCII 谱的设计目标为易于阅读不一样，VexTab 是为了可方便书写而诞生的。</p>
<p>下面就让我们开始学习书写这漂亮而美好的音符吧。</p>
<h2 id="第一步：谱表"><a href="#第一步：谱表" class="headerlink" title="第一步：谱表"></a>第一步：谱表</h2><p>关键字<code>tabstave</code>用于创建一行谱表，下面的编辑框都是可以进行编辑的，赶紧试一下在新的一行添加<code>tabstave</code>看看效果吧。</p>
<p><code>tabstave</code> 后面可以跟一些参数，比如<code>tabstave notation=true</code>的意思是显示一张标准的谱表(上面是五线谱，下面是六线谱)。别只看啊！动手试一下。</p>
<pre class="vex-tab-container">tabstave
</pre>

<h2 id="第二步：添加一些音符"><a href="#第二步：添加一些音符" class="headerlink" title="第二步：添加一些音符"></a>第二步：添加一些音符</h2><p>关键字<code>notes</code>可以用于添加音符。你可以通过在钢琴上的位置(<code>note/octave</code>)或者吉他指板的位置(<code>fret/string</code>)来表示。如果需要在同一根弦或者同个音区添加多个音符，可以通过这种表达式：<code>fret-fret-fret/string</code> (或者 <code>note-note-note/octave</code>)。根据你个人的喜爱来选择即可。</p>
<p>试着编辑一下下面的音符，留意它们在谱上的位置变化，结合下面的音区图去理解语法的作用。音符后可以跟随<code>#</code>, <code>##</code>, <code>@</code>, <code>@@</code>, 和 <code>n</code> 这几种记号，它们分别表示升半音，升全音，降半音，降全音和<a href="https://zh.wikipedia.org/wiki/%E8%BF%98%E5%8E%9F%E5%8F%B7" target="_blank" rel="noopener">还原音</a>。</p>
<pre class="vex-tab-container">tabstave notation=true tablature=false
notes Cn-D-E/4 F#/5</pre>

<p>盗一张图，结合这个图就明白<code>note/octave</code>方式了。</p>
<p><img src="http://yedaxia.oss-cn-shanghai.aliyuncs.com/personal/piano-pitches3-1024x375.jpg?x-oss-process=image/resize,w_500" alt="image"></p>
<p>下面是吉他谱：</p>
<pre class="vex-tab-container">tabstave notation=true
notes 4-5-6/3 10/4</pre>

<h2 id="第三步：谱表关键字"><a href="#第三步：谱表关键字" class="headerlink" title="第三步：谱表关键字"></a>第三步：谱表关键字</h2><p><code>tabstave</code> 可以跟随下面的参数：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>值/例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>notation</td>
<td>true/false</td>
</tr>
<tr>
<td>tablature</td>
<td>true/false</td>
</tr>
<tr>
<td>clef</td>
<td>treble, alto, tenor, bass, percussion</td>
</tr>
<tr>
<td>key</td>
<td>C, Am, F, Dm, Bb, Gm, Eb, Cm, Ab, Fm, Db, Bbm, Gb, Ebm, Cb, Abm, G, Em, D, Bm, A, F#m, E, C#m, B, G#m, F#, D#m, C#, A#m</td>
</tr>
<tr>
<td>time</td>
<td>C, C│, #/#</td>
</tr>
<tr>
<td>tuning</td>
<td>standard, dropd, eb, E/5,B/4,G/4,D/4,A/3,E/3</td>
</tr>
</tbody>
</table>
<p>例子：</p>
<ul>
<li><code>tabstave notation=true</code> 代表显示标准五线谱和六线谱。</li>
<li><code>tabstave notation=true tablature=false</code> 代表只显示五线谱。</li>
<li><code>tabstave notation=true clef=alto</code> 表示女低音谱号。</li>
<li><code>tabstave notation=true clef=bass key=C# time=C|</code> 表示 4/4 拍的低音谱，同时包含五线谱和六线谱。</li>
</ul>
<p>来试一下吧：</p>
<pre class="vex-tab-container">tabstave notation=true clef=bass key=Ab time=C|
notes 4-5/6</pre>

<h2 id="第四步：休止符和添加小节"><a href="#第四步：休止符和添加小节" class="headerlink" title="第四步：休止符和添加小节"></a>第四步：休止符和添加小节</h2><p><code>##</code> 表示休止符，默认会自动排好位置，你也可以通过在中间加个数字来改变所在的谱线，格式是<code>#4#</code>，值的范围是 0 到 9 。</p>
<p>小节的分隔符是<code>|</code>, 你可以在谱表中任意添加。</p>
<pre class="vex-tab-container">tabstave notation=true
notes 4-5-6/3 ## | 5-4-2/3 2/2

tabstave notation=true tablature=false
notes C-D-E/4 #0# | C-D-E-F/4</pre>

<p>另外，还有一些特殊的小节线。</p>
<ul>
<li><code>=||</code>  复纵线，表示乐曲告一段落，两条小节线是同样大小的</li>
<li><code>=|:</code>  重复开始</li>
<li><code>=:|</code>  重复结束</li>
<li><code>=::</code>  重复开始和结束</li>
<li><code>=|=</code>  终止线</li>
</ul>
<pre class="vex-tab-container">tabstave notation=true tablature=false
notes 4-5-6/3 ## =|: 5-4-2/3 2/2 =:|

tabstave notation=true tablature=false
notes C-D-E/4 #0# =:: C-D-E-F/4 =|=
</pre>

<h2 id="第五步：推弦音"><a href="#第五步：推弦音" class="headerlink" title="第五步：推弦音"></a>第五步：推弦音</h2><p>吉他演奏中常用的技巧，通过在指板数后添加<code>b</code>，就可以表示推弦音了。比如<code>10b12</code>表示一个全音推弦，<code>10b11</code>表示半音推弦，不难猜到<code>b</code>后面跟的是音的步值。那如何表示推高之后返回原来的音呢？答案就是 <code>10b12b10</code>，是不是很好理解。</p>
<pre class="vex-tab-container">tabstave
notes 4-5-6b7/3 10/4 | 5-4-2/3 2/2

tabstave
notes 6-7b9b7/3 7/4 | 9-8-7-6/2</pre>


<h2 id="第六步：哑音、上下拨弦和颤音"><a href="#第六步：哑音、上下拨弦和颤音" class="headerlink" title="第六步：哑音、上下拨弦和颤音"></a>第六步：哑音、上下拨弦和颤音</h2><p><code>X</code> 表示哑音，在音名后加小<code>v</code>表示颤音，大<code>V</code>则表示强颤音，同时你也可以推弦音后面加颤音，看下面的例子如何表示。</p>
<p><code>u</code> 和 <code>d</code> 分别表示上拨弦和下拨弦。</p>
<pre class="vex-tab-container">tabstave notation=true
notes 4-5-6b7v/3 10/1 | 5d-4u-Xd/3 2v/2</pre>

<h2 id="第七步：添加和弦"><a href="#第七步：添加和弦" class="headerlink" title="第七步：添加和弦"></a>第七步：添加和弦</h2><p>上面讲的都是单个音的表示，终于轮到和弦了。在谱上和弦是通过括号<code>()</code>和<code>.</code>来连接表示的，比如 C 和弦：<code>(C/4.E/4.G/4)</code>，当然也可以用指版数字的方法：<code>(1/2.2/4.3/5)</code>。</p>
<pre class="vex-tab-container">tabstave notation=true tablature=false
notes (C/4.E/4.G/4) C-E-G/4

tabstave notation=true
notes (8/2.7b9b7/3) (5b6/2.5b6/3) 7/4 |
notes (5/2.6/3.7/4)</pre>


<h2 id="第八步：击弦、勾弦、點弦-和-滑弦"><a href="#第八步：击弦、勾弦、點弦-和-滑弦" class="headerlink" title="第八步：击弦、勾弦、點弦 和 滑弦"></a>第八步：击弦、勾弦、點弦 和 滑弦</h2><p>这四种技巧分别用<code>h</code>, <code>p</code>, <code>t</code> or <code>s</code>,这个和一般吉他谱的表示是一样的。比如你要从6击弦到8然后再勾弦回6，就可以用<code>6h8p6</code>，你也可以在和弦上使用这些符号。</p>
<pre class="vex-tab-container">tabstave
notes (5/2.5/3.7/4) 5h6/3 7/4 |
notes t12p7p5h7/4 7/5 5s3/5

tabstave
notes (8/2.7b9b7/3) (5b6/2.5b6/3)v 7s0/4 |
notes (5/2.6/3.7/4)v

tabstave
notes (5/4.5/5)s(7/4.7/5)s(5/4.5/5) (5/4.5/5)h(7/5) |
notes t(12/5.12/4)s(5/5.5/4) 3b4/5 5V/6</pre>


<h2 id="第九步：加入音长-拍子-和连音"><a href="#第九步：加入音长-拍子-和连音" class="headerlink" title="第九步：加入音长(拍子)和连音"></a>第九步：加入音长(拍子)和连音</h2><p>默认都是4分音符(1/4拍)，你可以通过冒号<code>:</code>去改变它。</p>
<p>比如，<code>:w</code> 表示一个全音符。目前支持的音长有：全音符，二分音符，四分音符，8分音符，16分音符和32分音符，它们分别对于的符号是<code>w</code> <code>h</code> <code>q</code> <code>8</code> <code>16</code> <code>32</code>。如果要表示附点音符，则可以在相应的符号后面加<code>d</code>，例如：<code>:qd</code>。</p>
<p>连音的符号是<code>^</code>，比如八分音符的三连音表示为：<code>:8 4-5-6/4 ^3^</code>。</p>
<pre class="vex-tab-container">tabstave notation=true time=4/4 key=Ab tuning=eb
notes :8 5s7s8/5 ^3^ :q (5/2.6/3)h(7/3) :8d 5/4 :16 5/5</pre>

<p>下面是更复杂的例子，它演示了如何在滑音，推弦音等其他技巧音上使用音长。请你认真体会。</p>
<pre class="vex-tab-container">tabstave notation=true
notes :q (8/2.7b9b7/3) (5b6/2.5b6/3)v :8 7s12/4
notes t:16:9s:8:3s:16:0/4</pre>

<h2 id="第十步：歌词，注释或者其他文本"><a href="#第十步：歌词，注释或者其他文本" class="headerlink" title="第十步：歌词，注释或者其他文本"></a>第十步：歌词，注释或者其他文本</h2><p>你可以通过美元符号 $  中间附上逗号<code>,</code>来分隔文本来添加注释。你可以用于歌词，和弦提示，或者一些弹奏提示中。</p>
<p>$.top.$ 表示在注释在谱线上面，$.bottom.$ 表示在下面。</p>
<pre class="vex-tab-container">tabstave notation=true time=4/4 key=Ab tuning=eb
    notes :q 5/5 5/4 5/3 ^3^ $Fi,Ga,Ro!$ :h 4/4 $.top.$ $Blah!$</pre>

<p>有两种方式去改变注释样式，一种是用预设的样式，一种是自定义的样式。对于预设的方式，你只需要在美元符号中添加<code>.style.</code> + 预设的样式就可以了，比如 $.big.C Major$ 表示大码的<code>C Major</code>显示。</p>
<p>目前预设的样式有<code>big</code>、 <code>medium</code> 和 <code>italic</code>。</p>
<p>对于自定义的方式，语法是这样的：<code>.face.size.style</code> ，<code>face</code>表示字体，<code>size</code>表示字体大小，<code>style</code> 是字体样式（斜体：italic，加粗：bold）。例如  $.Times-14-italic.Blah$ 表示 14pt 大小、斜体、Italic Times Roman 字体的文本注释文本 Blah。</p>
<pre class="vex-tab-container">tabstave notation=true key=A
notes :q (5/2.5/3.7/4) $.big.A7#9$ 5h6/3 7/4 |
notes :8 7/4 $.italic.sweep$ 6/3 5/2 3v/1 :q 7v/5 $.Arial-10-bold.P.H$ :8 3s5/5</pre>

<h2 id="第十一步：断音-Staccatos-，延音-Fermatas-等更多衔接音。"><a href="#第十一步：断音-Staccatos-，延音-Fermatas-等更多衔接音。" class="headerlink" title="第十一步：断音(Staccatos)，延音(Fermatas)等更多衔接音。"></a>第十一步：断音(Staccatos)，延音(Fermatas)等更多衔接音。</h2><p>你可以通过  $.articulation/position.$ 这种语法来添加衔接音。不同的衔接音有不同的符号表示。 <code>a.</code> 代表 staccato,<code>a@a</code> 代表 up-fermata，它们可以放置在谱线的上面或者下面。</p>
<p>下面的列表展示了所有支持的衔接音。</p>
<pre class="vex-tab-container">options space=20 font-style=italic
font-face=times font-size=10

tabstave notation=true tablature=false
notes :q
notes C/4 $.a./bottom.$
notes E/4 $.av/bottom.$
notes G/4 $.a>/bottom.$
notes B/4 $.a-/bottom.$
notes C/5 $.a^/top.$
notes E/5 $.a+/top.$
notes G/5 $.ao/top.$

text :q,.-1,.strict,Stacatto,Staccatissimo
text Accent,Tenuto,Marcato,LH pizzicato,Snap pizzicato
text ++,.12,.font=courier-12-,:q,a.,av,a>,a-,a^,a+,ao

options space=120 font-style=italic
font-face=times font-size=10

tabstave notation=true tablature=false
notes :q
notes C/4 $.ah/bottom.$
notes E/4 $.a@a/top.$
notes G/4 $.a@u/bottom.$
notes B/4 $.a|/bottom.$
notes C/5 $.am/top.$

text :q,.-1,.strict,Open Note,Up Fermata
text Down Fermata,Bow Up,Bow Down
text ++,.12,.font=courier-12-,:q,ah,a@a,a@u,a|,am

options space=40
</pre>

<h2 id="第十二步：更多的文本"><a href="#第十二步：更多的文本" class="headerlink" title="第十二步：更多的文本"></a>第十二步：更多的文本</h2><p>VexTab 还提供了一种非常灵活添加文本的方式，利用<code>text</code>关键字可以创建和音符垂直对齐的文本，这种方式非常合适于放置和弦的名称。</p>
<p>在下面的示例中，我创建了两个文本块， “G Minor” 和 “A Major”，每个都是二分音符。注意这里文本块的音长间隔之间使用逗号隔开的，除了这一点，音长规则表示也是和音符一样的。</p>
<pre class="vex-tab-container">options space=12 font-size=14

tabstave notation=true time=4/4 key=Ab tuning=eb
notes :q 5/5 5/4 5/3 ^3^ :h 4/4
text :h,G Minor,A Major</pre>

<p>可以通过<code>.数字</code>这种方式来跳转文块在垂直方向上的位置，默认是0，表示在谱的上面，这个值越大，表示越往下，如果值是负数，则越小越往上面。</p>
<pre class="vex-tab-container">options space=10

tabstave notation=true tablature=false time=4/4 key=Ab tuning=eb
notes :8 C-D-E-F-G-A-B/4 C/5
text :8,.1,Do,Re,Me,.10,Fa,So,La,Ti,.1,Do

options space=10</pre>

<p>像音符一样，你也可以通过<code>|</code>来分隔文本小节，这样可以更好的对齐，另外，你还可以通过<code>++</code>语法来在同一行谱线上创建新的一行文本。简直太强大有木有～</p>
<pre class="vex-tab-container">options space=10 font-size=12

tabstave notation=true tablature=false
time=4/4 key=Ab tuning=eb
notes :q C-D-E-F/4 | G-A-B/4 C/5
text :h,.1,C,Em,|
text :h,G7,C
text ++, .11, :w, This is a new text line.

options space=15
</pre>

<p>还没完，你还能在文本上添加很多音乐符号，比如结尾和重复。只需要在关键字前面加上<code>#</code>就可以了，e.g., <code>text #coda</code>。</p>
<pre class="vex-tab-container">options space=20 font-size=12

tabstave notation=true tablature=false
time=4/4 key=Ab tuning=eb
notes :q =|: C-D-E-F/4 =:| G-A-B/4 C/5
text |#coda, :hd, , :q, #tr, |#segno
text ++, .11, |, #f
text ++, .0, .font=Times-12-italic, |, :w, ,|, :q, ,D.S. al coda

options space=25</pre>

<h2 id="第十三步：旋律斜线记法"><a href="#第十三步：旋律斜线记法" class="headerlink" title="第十三步：旋律斜线记法"></a>第十三步：旋律斜线记法</h2><p>在音长符号前面加上大写<code>S</code>就可以变成斜线的记法了。在下面的示例中，你可以尝试改一下音名看看效果。你也可以通过 <code>u</code> 或 <code>d</code> 来表示动作的上下。</p>
<pre class="vex-tab-container">options font-size=14 space=15

tabstave notation=true tablature=false
time=4/4 clef=percussion
notes :2S Bd/4 :qS Bd/4 :q ## | :8S Bd/4 Bu/4 :qS Bd-Bu-Bd/4 ^3^
text :w, G Maj7, |, Am

options space=10</pre>

<h2 id="第十四步：定义外观"><a href="#第十四步：定义外观" class="headerlink" title="第十四步：定义外观"></a>第十四步：定义外观</h2><p>定义外观主要是通过<code>options</code>的参数来完成的，你可以根据喜好更改字体，谱的大小和美化谱线距离等。比如 <code>options width=400</code> 表示谱的宽度是 400 像素。</p>
<p>下面是相关的参数列表。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>谱的宽度，单位是像素</td>
</tr>
<tr>
<td>scale</td>
<td>缩放系数，默认是1</td>
</tr>
<tr>
<td>space</td>
<td>和下一行谱线的距离，单位是像素</td>
</tr>
<tr>
<td>stave-distance</td>
<td>五线谱和六线谱之间的距离，单位是像素</td>
</tr>
<tr>
<td>font-face/font-style/font-size</td>
<td>注释字体的默认参数</td>
</tr>
</tbody>
</table>
<p>加多一些空间给在谱线比较高位置的音：</p>
<pre class="vex-tab-container">options width=100 scale=2.0
tabstave notation=true tablature=false
notes :q 5/5</pre>

<p>加多一些空间给在谱线比较高位置的音：</p>
<pre class="vex-tab-container">options space=40 font-size=14
tabstave notation=true key=A
notes :q (5/2.5/3.7/4) $A7#9$ 15h16/1 20/1
</pre>

<p>让五线谱和六线谱距离更远：</p>
<pre class="vex-tab-container">options stave-distance=50
tabstave notation=true key=A
notes :q (5/2.5/3.7/4) ## 0h1/6 0/1
</pre>


<h2 id="第十五步：六线谱也可以带拍号"><a href="#第十五步：六线谱也可以带拍号" class="headerlink" title="第十五步：六线谱也可以带拍号"></a>第十五步：六线谱也可以带拍号</h2><p>添加 <code>tab-stems</code> 参数就可以在六线谱上显示拍号了。对于单独的人声旋律谱，你可以通过 <code>tab-stem-direction</code> 参数来指定拍号的方向。</p>
<p>注意你需要改变一下 <code>space</code> 和 <code>stave-distance</code> 参数值来避免出现重叠。</p>
<pre class="vex-tab-container">options space=12 font-size=14
tab-stems=true tab-stem-direction=up

tabstave time=4/4 key=A
notes :8 5/5 5/4 5/3 ^3^ :16 5-6-7-8/1 :8 9s10/1 :h s9v/1</pre>

<h2 id="第十六步：播放你的音符"><a href="#第十六步：播放你的音符" class="headerlink" title="第十六步：播放你的音符"></a>第十六步：播放你的音符</h2><p>添加 <code>player</code> 参数等于 <code>true</code>，还要指定拍子的速度<code>tempo</code>，就可以立即播放你写的音符了。</p>
<pre class="vex-tab-container">options space=20 player=true  tempo=80

tabstave
notation=true
key=A time=4/4

notes :q =|: (5/2.5/3.7/4) :8 7-5h6/3 ^3^ 5h6-7/5 ^3^ :q 7V/4 |
notes :8 t12p7/4 s5s3/4 :8 3s:16:5-7/5 :h p5/4
text :w, |#segno, ,|, :hd, , #tr</pre>

<h2 id="词汇表："><a href="#词汇表：" class="headerlink" title="词汇表："></a>词汇表：</h2><ol>
<li>stave: 谱表</li>
<li>note: 音符</li>
<li>octave: 八度音阶</li>
<li>fret: 指板</li>
<li>natural: <a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%9F%B3%E8%AE%B0%E5%8F%B7" target="_blank" rel="noopener">还原音</a></li>
<li>time：节拍</li>
<li>tuning: 起音</li>
<li>clef: 谱号</li>
<li>tablature: 谱式，记谱法</li>
<li>treble: 最高声部，高音部</li>
<li>alto: 女低音，中音部</li>
<li>tenor: 男高音</li>
<li>bass: 男低音，低音部</li>
<li>percussion: 打击乐器</li>
<li>common time: 4/4 拍。</li>
<li>rest: 休止符</li>
<li>double bar: <a href="https://zhidao.baidu.com/question/281000868.html" target="_blank" rel="noopener">复纵线</a></li>
<li>mute note: 哑音</li>
<li>vibrato: 颤音</li>
<li>chord: 和弦</li>
<li>hammer-on: 击弦</li>
<li>pull-off: 勾弦</li>
<li>tap: <a href="https://www.bilibili.com/video/av9756522/" target="_blank" rel="noopener">點弦</a>，轻敲吉他</li>
<li>slide: 滑弦</li>
<li>lyrics: 歌词</li>
<li>articulation: <a href="https://zh.wikipedia.org/wiki/%E9%8A%9C%E6%8E%A5_(%E9%9F%B3%E6%A8%82" target="_blank" rel="noopener">衔接</a>)，是音乐上的方向或技术。它影响到乐曲里音符之间的过渡或连续性。</li>
<li>staccato: (意大利语) <a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E5%A5%8F" target="_blank" rel="noopener">断音</a>，断奏，指音符的实际时值比谱上所示的短，而减短的部分则可不作声，并于音符上加上一小点表示。</li>
<li>fermata: 延音</li>
<li>staccatissimo: 特断音</li>
<li>accent: 重音</li>
<li>codas: 尾奏</li>
<li>segno: 连续记号</li>
</ol>
<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>
<script src="/js/src/vextab/paper.min.js"></script>
<script src="/js/src/vextab/underscore-min.js"></script>
<script src="/js/src/vextab/vexflow-min.81.js"></script>
<script src="/js/src/vextab/tabdiv-min.81.js"></script>
<script src="/js/src/vextab/vextab-support.js"></script>
<script>
    $('.vex-tab-container').each(function(index, el) {
        $this = $(el);
        var width = $('.post-body').width() * 0.9;
        var scale = 0.8;


        $this.attr('editor', "true");
        $this.attr('editor_height', "120");


        $this.attr('width', width / scale);
        $this.attr('editor_width', width);
        $this.attr('scale', scale);

        opts = {};
        opts.soundfont_url = '/soundfont/';

        new Vex.Flow.TabDiv(this,opts);
    });
</script>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VexTab 是一种用于书写音乐的语言，你只需要花非常少的时间学习一下，就可以用它来创建，编辑和分享非常好看的五线谱和六线谱了。和 ASCII 谱的设计目标为易于阅读不一样，VexTab 是为了可方便书写而诞生的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="音乐编程" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个会弹吉他の人, 他的一生 | 9个视频拼成的故事</title>
    <link href="https://yedaxia.github.io/Story-Of-A-Guitarist/"/>
    <id>https://yedaxia.github.io/Story-Of-A-Guitarist/</id>
    <published>2018-01-29T16:30:05.000Z</published>
    <updated>2018-01-31T12:01:43.077Z</updated>
    
    <content type="html"><![CDATA[<p>不如，讲个故事给你听如何？名字就叫做「一个会弹吉他の人，他的一生」吧。文后有吉他谱。</p>
<a id="more"></a>
<p>我把这些天手机录的视频凑在一起，拼成一个小故事给你。名字就叫做「一个会弹吉他の人，他的一生」吧。</p>
<p>上学的时候，除了刻苦学习，望着教室的窗外发呆，你还会期待每天的下课铃声，和 Ta 一起慢悠悠走去饭堂。</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM2MzQzNDAwMA==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲: 等你下课 - 周杰伦</p>
</blockquote>
<p>美好的时光总是过的那么快，到了毕业的季节，为了生存，我们不得各奔东西。一个人在外面奋斗，难免有感到孤独的时候，但也要学会过的很快乐。</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM1NTc1NjM0MA==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：再见二丁目-杨千嬅<br>歌词：原来过得很快乐，只我一人未发觉，如能忘掉渴望，岁月长 衣裳薄</p>
</blockquote>
<p>有时候遇到困难，感觉坚持不下去了，告诉自己，别轻易放弃。在这个世界上，还有很多甚至身体都不健全的人都在为自己的生命在努力勇敢的走下去，我已经很幸运了，别想这么多，你还年轻，喜欢的事，做下去就是了。</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM2MzQzMDY5Ng==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：稻香-周杰伦<br>歌词：为什麽人要这麽的脆弱 堕落，请你打开电视看看，多少人为生命在努力勇敢的走下去</p>
</blockquote>
<p>你靠会弹点吉他找到了自己的初恋，但是由于情商太低，很快就失恋了。虽然内心悲痛，但请祝福对方可以找到更好的，感谢你曾经来过，带给我美好的回忆。</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM2MzQzMjk2MA==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：someone like you - adele<br>歌词：Never mind, I’ll find someone like you, I wish nothing but the best for you</p>
</blockquote>
<p>时光荏苒，你终遇到了对的Ta，你们携手走进了婚姻的殿堂，开始了人生的下一个阶段，在婚礼上，你在心里默念：</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM1MjMxMDk5Ng==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：(better man)做更好的男人(中文版)<br>歌词：做为一个男人 呵护爱他的女人 别让她哭泣 那是一生的责任</p>
</blockquote>
<p>爱情的结晶如约而至，你感觉到身上的责任更重了，偶尔会和心爱的人还发生一些小争吵，难免有心烦意乱的时候，有时候需要适当放空一下，约三两知己，解酒消愁：</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM0OTQ4NjMxMg==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：消愁-毛不易<br>歌词：一杯敬明天 一杯敬过往，一杯敬自由 一杯敬死亡</p>
</blockquote>
<p>不知觉人生过半，经过半个世纪的人情世故，你内心无比明亮，明白到，世事不可强求，要顺其自然。</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM1ODgyMDU3Mg==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：Whatever Will Be, Will Be - Doris Day<br>歌词：Que sera, sera, Whatever will be, will be, The future’s not ours to see , Que sera, sera</p>
</blockquote>
<p>无论你如何眷恋或厌恶，无论你贫穷或是富贵，终究难逃命运的轮回，我希望有人会记得我的名字。</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM2MzQzNDk3Ng==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌曲：Tears in Heaven<br>歌词：Would you know my name , If I saw you in heaven? </p>
</blockquote>
<p>有时候我会想，时间的本质究竟是什么? 我们经历的过去，就在你看我文章上一个视频那个瞬间，它还在吗？如果存在一个解忧杂货铺，给你一个写给过去的自己一封信的机会，你会对自己说些什么？</p>
<iframe height="250" width="400" src="http://player.youku.com/embed/XMzM2MTU1MzE5Ng==" frameborder="0" 'allowfullscreen'=""></iframe>

<blockquote>
<p>歌词：歌曲：解忧杂货铺主题曲-重生<br>歌词：如果有天可以让你选择，人生重来或继续？告诉你吧，我也曾面临这难题，而你现在看到的，是谜底。</p>
</blockquote>
<p>The End！</p>
<p>Do you like it? Please let me know.</p>
<p><strong>附上扒的吉他谱：</strong></p>
<p><a href="http://52cmajor.com/tab/1363502" target="_blank" rel="noopener">等你下课-吉他谱</a></p>
<p><a href="http://52cmajor.com/tab/1363958" target="_blank" rel="noopener">再见二目丁吉他谱</a></p>
<p><a href="http://52cmajor.com/tab/1363957" target="_blank" rel="noopener">better man 吉他谱</a></p>
<p><a href="http://52cmajor.com/tab/1363956" target="_blank" rel="noopener">消愁-吉他谱</a></p>
<p><a href="http://52cmajor.com/tab/1364061" target="_blank" rel="noopener">解忧杂货铺主题曲-重生-吉他谱</a></p>
<p><a href="http://52cmajor.com/tab/1364104" target="_blank" rel="noopener">whatever will be, will be-吉他谱</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不如，讲个故事给你听如何？名字就叫做「一个会弹吉他の人，他的一生」吧。文后有吉他谱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>如何准备一场高质量的 Busking</title>
    <link href="https://yedaxia.github.io/how-to-prepare-a-busking/"/>
    <id>https://yedaxia.github.io/how-to-prepare-a-busking/</id>
    <published>2018-01-10T06:56:14.000Z</published>
    <updated>2019-01-10T16:08:19.581Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个 busker，你要对得起这个身份，你对自己的要求不能低！</p>
<a id="more"></a>
<p><img src="/assets/darcy_blog_photo-1486994816305-105a487dac3b.jpeg" alt=""></p>
<h1 id="什么是busking"><a href="#什么是busking" class="headerlink" title="什么是busking?"></a>什么是busking?</h1><p>维基百科的释义：</p>
<p>街头表演艺术 (英文: Busking)，是一种在街头上的表演艺术，此类艺术表演可能是即兴，也可是表演者每天的谋生活动， 通常在爱才者或欣赏者观点，相信此类谋生表演者是“街头艺术家”，或者尊称为街头艺人，他们跟乞丐的行为明显不同，前者的重点是展现自我才华的行为，后者目的是恳求捐赠。</p>
<p>在音乐方面，我们通常把这种行为成为卖唱。</p>
<p>Busking 是一种非常自由的活动，它可以降低音乐表演的门槛，不需要一个专门的场地和设备，在城市中找一块没有城管赶人的空地就随时可以进行。比如我所在的城市广州，在周末的珠江边，你很容易就碰到他们的身影。</p>
<p>在旅途中，能遇到一场高质量的 busking 是一件幸事，被音乐包围的城市不会太差。</p>
<h1 id="busking-对个人的意义"><a href="#busking-对个人的意义" class="headerlink" title="busking 对个人的意义"></a>busking 对个人的意义</h1><p>你可能已经练习吉他好几年了，也有过来一场 busking 的想法，可能由于一些顾虑阻挡了你的脚步，比如怕唱的不好，没人听；缺乏经验，怕临场发挥不好。Busking 本身是非常锻炼你的能力的，在没有人请你去驻场或者商演之前，这是一种不错的练习方式，如果你连这一步都不敢踏出，那这辈子只能唱给自己听了。另外一点是 busking 要不要接受打赏，这让人感觉到好像在乞讨一样。在现实中，不少音乐人在没有名气之前都是靠一些驻场演出或者 busking 来维持生活的，这点我觉得可以这么看，购买唱片，演唱会门票听明星唱歌，本质上和在街头唱歌给钱都是为了表达一种喜爱或者支持，只要人们是出于欣赏而不是可怜的心态给你一些回报，我觉得是可以大方去接受的，毕竟准备一场 busking 是很费时费力的，这也是对你的一种很重要的考验指标，愿意给你打赏的观众一定是被你打动了。</p>
<p>如果你鼓起勇气打算进行一场 busking，我相信你收获的一定比你想象的多。无疑，一场好的 busking 是需要花大量的时间来准备的，不过我相信你足够热爱，不会认为是一件苦差事。</p>
<p>如果你已经是一个 busker，你要明白你进行此项活动的一个重要目的系提升自己，而不是仅仅为了谋生。就好像某个访谈里面有说过的：“你要对得起这个身份，你对自己的要求不能低”。</p>
<h1 id="如何准备"><a href="#如何准备" class="headerlink" title="如何准备"></a>如何准备</h1><p>我认为，一场好的 busking，不仅是自己享受其中，也应该是可以给别人带来美的享受的。我们也会在街头碰到过一些唱的不好，吉他弹的也一般的，路人可能就真是匆匆走过，头也不回了。一场好的 busking，必然要好好准备。</p>
<p>最重要的当然是先把你的曲子和歌练好了，一场 busking 假如是 2 个小时，那你至少要准备 20 首歌左右吧，如果你还要看谱才能完成的话，就好像演讲要看稿子一样，可能准备还不够充分。</p>
<p>请尽可能用好一点的设备，烧火棍明显会让你的水平大打折扣，但是也不用准备的太豪华了，户外的环境对乐器的不安全因素会增多。</p>
<p>场地选择也是很重要的，首先是要合法啦，不能地铁里面，居民区或者明文禁止的闹市中来进行，被城管没收了设备就不好了。我个人建议选址在一些有些文艺范的地方，不要太嘈杂的地方为好。当然，如果运气不好，碰到了城管，也不要慌。知乎上有个小段子描述：“在你慌乱的同时，不要忘了，路人还在旁边！你不能前一秒还是文艺范，北漂范，摇滚范，历经红尘沧桑范，后一秒就脸色苍白，神情慌乱的如同丧家犬一般”。当然我相信你不会的，跟观众道个歉，慢慢收拾好，优雅离开就好了。</p>
<p>最后向你推荐一个让你的演出和现场观众更好进行互动的小助手，这也是我今年做的第一个小产品。通过它，观众可以点自己想听的歌，一起唱歌，可以发弹幕，更重要的是，可以在微信内方便进行打赏，毕竟现在出门带现金的越来越少了。为了降低使用门槛，观众无需注册就可以直接进行使用了，希望它可以为你的演出之路赋能！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个 busker，你要对得起这个身份，你对自己的要求不能低！&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="https://yedaxia.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>我的 2017 总结</title>
    <link href="https://yedaxia.github.io/my-2017-summary/"/>
    <id>https://yedaxia.github.io/my-2017-summary/</id>
    <published>2018-01-01T06:56:33.000Z</published>
    <updated>2018-02-03T07:00:55.172Z</updated>
    
    <content type="html"><![CDATA[<p>青春的尾巴，这是一个普通程序员的2017。</p>
<p>随手写一下，想到哪就写哪吧。</p>
<a id="more"></a>
<p>又一年就这样过去了，作为第一批 90 后，站在青春的尾巴上，感觉时间的流动速度是越来越快了。自从罗胖发愿每年都做一次跨年演讲后，这几年的跨年活动就成了向优酷买个门票，然后坐在屏幕前听他唠嗑好几个小时。即使只是一介布衣，但对于了解这个世界的渴望也是强烈的。</p>
<p>17年是毕业的第四个年头了，应该是写代码最多的一年了，似乎一整年都在马不停蹄地码码码。</p>
<p>今年比较大的一个决定就是辞了工作，没想到这一辞就是半年。之前是有想做一个共享图书的 App，一开始找了几个在职的朋友利用业余时间做，但是大家积极度不是很好，我意识这样下去不可能完成后，决定辞了工作全职投入去做，当然还有一点是我对公司不太满意，也有想离开的想法了。这个项目最后只剩我自己一个人在做了，后面找了个前面带过的做 Android 的师弟，最终总是是把产品的雏形完成了。</p>
<p>最终没有上线。这是一次很失败的实践，第一是没有能围绕这个产品能建立一只小团队，其次是产品比预想的要复杂很多，要让闲置的图书能流动起来，我开始意识到这件事情没那么简单。后来看到了多抓鱼，我觉得这个 App 没有上线的必要了，这才是闲置图书的正确处理方式啊！另外也只开发了 Android 端，没有资金去推广，这也是其中一个原因。不得不说一下，这是一次极大的技术选型错误，不要仅因为个人熟悉某个技术就去选择这个平台，要综合考虑，尤其是成本，其实一开始选择微信公众平台或者小程序来做是极好的，再次提醒大家，不要轻易做 App，先不说你要兼顾 iOS 和 Android 平台的升级、兼容等，现在让别人愿意装上你的 App 试一下都 已经是一件很难的事情了。</p>
<p>为了做这个产品，在快法务找了个代理注册了个公司，当时也没想着要要怎么经营，只是为了方便申请一些接口什么的，也是为了表明我的一个态度：对于这件事情，我是认真的。后面想想这件事情决定真是有点鲁莽了，其实找朋友公司借个资质这种方式明显会更合理一些，不要总是怕麻烦别人。不管怎么样，就这样糊里糊涂有了一个法人的身份～ 有时候没有考虑太多，走步看步，还好还只是我一个人的公司，不用给别人发工资，只需要对自己负责就好了。</p>
<p>从这个原型开始设计到最后的失败，中间还夹杂了和女朋友分手，后面又复合等一些让人焦头烂额的事情，想来人生真是充满了不确定性啊，那个你思前想后并试图证明是正确的选项，可能是不存在的，但更可能是我缺乏足够的智慧。有记得以前大学一同学的 qq 签名，路是自己选的，既然已经做了决定，就要勇敢走下去。也许这才是答案。</p>
<p>因为没有收入来源，中间曾一度还有些焦虑，其实现在有时也会，不过已经可以比较好的处理这种情绪了。有试图去找一些外包、在线授课等一些方式来增加收入，等真的有外包找上来的时候，发现这个钱不好赚啊，除非你已经有了一些模块能刚好快速拼装起来，你要给他从头开始开发，这是极度不划算的，合适的外包太少了。后来慕课网有让我试录一个视频，目标是一个中高级的 Android 课程，而且要明年才会开课，但那段时间正在拼命码 C 大调这个网站，被催了几次，拖了一个月，后面只能跟妹子说实在没空了。</p>
<p>C 大调网站，是在做共享图书之后又开始的一个新产品。除了编程，吉他算是我的第二大爱好了。当时想，如果有一件事能一直坚持做下去，那必须要热爱才行。懂一点理财之后，我认识了一个新词汇叫做复利，做自己热爱的事情，持续投入，必定会产生极大的复利。反过来看，如果不喜欢，我很难坚持。</p>
<p>我开始探索这条路径，这次我把平台锁定到 web + 微信平台上，采用响应式的 web 框架 boostrap 来构建应用，可以一次打通 PC，平板 和手机，抵达所有的主流平台。思路也发生了改变，不要急着动手，先了解这个行业大概的样子，当然这需要不断学习，有时候知道的太多看到前面巨大的阻力反而丧失了勇气。花了一周左右做了个简单的搜索引擎，把主流的吉他网站的谱爬了过来，你得先做个东西表明一下态度，然后从身边的一些从事音乐行业相关的朋友去了解，当时也想借这个机会看看有没有合适的合伙人。</p>
<p>做这个音乐网站，心里其实是很没谱的。有初具规模的《弹琴吧 App》 靠智能设备和社区来连接初级爱好者的，音乐培训也已经有 Finger App 这样的重量级对手了。你必须要做不一样的事情才可能有机会。</p>
<p>即使热爱，也得想办法先活下来。中间花了一个月多来做了对接线下培训的课程模块，把微信的支付和公众平台对接上了，还涉及到一些复杂的税务问题，然后回过头来又发现流量不大，帮不了人，还要处理一堆麻烦事，拿不出手的东西只能先 hold 着。于是又回过头来想办法攒流量了，这时候公众号已经和系统可以互通了，很自然而然就想到把用户先往公众号引流过去，又进一步完善了搜谱和功能，和开发了一些好用的工具在公众号里面。</p>
<p>这里要感谢一些知乎和豆瓣一些陌生网友的支持，帮我在他们的高票回答或者小组里面加了了网站的链接，还有很多肯定的鼓励。我会带着这些力量在后面做的更好。</p>
<p>尽管到今天为止依然在摸索，但似乎可以找到一个方向做下去了，如果不是也没关系，换条路便是了。不管怎么样，信心是有的。</p>
<p>学习音乐虽然不像外语和技术那么功利，给个机会让它抵达，你一定会爱上它。</p>
<p>脱离了工作岗位之后，感觉整个人的视野和思维都开阔了许多，技术上接触也越来越宽泛了，从前端、后端开发到运维，都一手包办了。当然有很多东西都还来不及深入去了解，对于这点，我的看法是技术是用来解决问题的，不用过于沉迷，捡重点，该花时间钻研的地方，一定要耐住性子，把时间花到最有价值的地方。跟音乐相关的编程，国内了解的人不多，这方面就值得花大功夫。</p>
<p>记录个插曲，由于做的开源项目 JApiDocs 受到红薯大哥的待见，因此在广州的源创会上有幸当了一回嘉宾，作为码农，写了这么久代码，能得到一点肯定，这也是是最值得高兴的一件事情了。说起这个项目，也好几个月没更新了，得抽个时间把一些需求给补上啊。</p>
<p>写着写着不知不觉已经来到了 2018 年的第二天了，有了一丝困意，感觉有点唠叨了，赶紧结束了吧。</p>
<p>2018 年，但行好事，莫问前程。锻炼好身体，按时作息，赚钱。就先这样吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;青春的尾巴，这是一个普通程序员的2017。&lt;/p&gt;
&lt;p&gt;随手写一下，想到哪就写哪吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人成长" scheme="https://yedaxia.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>初为程序猿(媛)的你，这些技能为你们加持</title>
    <link href="https://yedaxia.github.io/Some-Recommend-Skills-For-Primary-Programmer/"/>
    <id>https://yedaxia.github.io/Some-Recommend-Skills-For-Primary-Programmer/</id>
    <published>2017-08-28T06:36:42.000Z</published>
    <updated>2019-01-10T16:08:19.591Z</updated>
    
    <content type="html"><![CDATA[<p>每个程序员应该精挑细选和打磨他的工具箱，这里推荐的东西都是本人使用频次比较高的，不是奇淫巧技，也不需要花很多时间，但是会让你收益超额的，至少对我来说是这样的。</p>
<p>这是很有诚意的一篇文章，你可以选择一笑而过，也可以默默收藏。</p>
<a id="more"></a>
<h1 id="一个自己的博客"><a href="#一个自己的博客" class="headerlink" title="一个自己的博客"></a>一个自己的博客</h1><p>笔者从大学就开始写博客，从 WordPress 到自己用 JFinal 写了一个，中间有断了几次，不想再续费服务器，对写的东西也不太满意，索性用 Github Pages + hexo 重新开始写。</p>
<p>个人觉得写博客，首先是为自己而写的，其次可能对他人有帮助。单纯地阅读而不思考收获会大打折扣的，写出来就是一个行之有效的思考整理过程。</p>
<p>我推荐用 Github Pages + hexo 的方式，一开始你可能和我一样写的不好，没什么人看，记住，首先你是给自己写的，坚持原创和记录，你会变的更好，等觉得拿的出手了，可以开始在一些平台上发表，比如掘金，简书。</p>
<ul>
<li><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">为什么你应该（从现在开始就）写博客 - 刘未鹏</a></li>
<li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></li>
<li><a href="https://github.com/ruanyf/document-style-guide" target="_blank" rel="noopener">中文写作规范 - 阮一峰</a></li>
</ul>
<p>花半天时间把自己的个人博客给搭建起来吧。</p>
<h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>不能用 Google，就失去了世界上最大的百科全书的使用权，这个损失是巨大的！每天都会遇到无数问题的我们，学会越过这道墙成了一个必备的技能。</p>
<p>我建议自己买一台国外的服务器，AWS、阿里云等，最低配就可以了，可以几个人一起用，分担一下费用，稳定又安全，还可以在上面折腾点别的，这点投资我觉得是超值的。By the way, AWS 有一年的免费额度，阿里云也在搞活动，¥330 一年的（香港）国外节点。如果还是觉得麻烦，那至少应该去买个账号吧。(真的没收广告费)</p>
<p>搭建一个这样的服务真的超级简单，几行命令就能搞定。</p>
<ul>
<li><a href="https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Shadowsocks 使用说明</a></li>
</ul>
<p>服务端和客户端教程都可以在上面找到，如果有服务器的前提下，大约花你 30 分钟就能使用全球最大的百科全书了。</p>
<h1 id="git-amp-github"><a href="#git-amp-github" class="headerlink" title="git &amp; github"></a>git &amp; github</h1><p>git 是个伟大的协作和版本管理工具，这几年经过社区的传播和国内越来越多 git 代码托管平台的崛起，现在 git 应该碾压乌龟 SVN 作为很多团队和公司的首选版本管理工具了，如果你还没有开始使用 git ，很遗憾你已经拖后腿了。</p>
<p>作为全球最大的源(程)代(序)码(员)托(社)管(交)平台 github ，以前我还不知道它有什么用，和很多人一样，注册之后很长时间里面就放了几个 Demo ，然后就不怎么管了。以前写代码就是蒙着写，不会就 Google 一下，不小心就会造一个重复的轮子出来 (<a href="https://github.com/YeDaxia/SQLiteUtils" target="_blank" rel="noopener">SQLiteUtils</a>: 实际是 4 年前写的，后来改了名字重新上传)，这样其实是很不好的，闭门造车不仅仅是浪费时间，还可能阻碍了你的认知，自我感觉良好而已。移动互联网的快速发展，尤其是 Android ，涌现了很多优秀的开源作品，大家也开始会用 github 去搜索，收藏一些好的作品，学习并使用到自己的项目中。如果你只去使用那些公认足够 solid，有完整翻译过来的中文文档，百度一搜就有一堆答案的 library 或者 tools，可能你已经落后新生代的程序员一大截了。另外如果你有留意，越来越多的公司都把简历上的技术博客、 github 作为一个非常重要的加分项了，反正我在写 JD 和面试之前真的回去翻看对方的博客和 github 仓库的。</p>
<p>要写出好的文章，阅读大量的优秀文章是必不可少的；要写出优秀的代码亦如此，学会参与到一些开源项目中 ( 使用它；给它提建议和bug；动手修改它，提交你的 PR )，学着自己动手构建一个开源项目和维护它，这件事情需要极大的热情，但你会得到同行的支持和认可，为你的职业生涯添砖加瓦。</p>
<ul>
<li><a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">Pro Git（中文版）</a></li>
</ul>
<p>打开看到这么多东西，你可能又退回去使用你的乌龟了，我的建议是先注册个 github，简单了解一下 git 的原理和一些简单的命令，常用的命令其实非常少。git 的学习成本相对高，你可能至少花半天的时间去仔细研究一下，并且需要后面不断去总结和精进，当你熟练掌握的那一天，你一定会感激当初的自己。</p>
<h1 id="持续集成-CI"><a href="#持续集成-CI" class="headerlink" title="持续集成(CI)"></a>持续集成(CI)</h1><p>如果你在搭建自己的小网站，那么第一件事应该是让你的代码一写好然后就能一键发布到服务器上，这个技能就叫持续集成(continuous integration)。当然这个是狭义的解释哈。优秀的程序员应该有一个强烈的意识：dont repeat yourself. 不要做重复的工作。如果你是和我一样的 Java 程序员，每次打包上线重重复着修改配置 -&gt; 打包 war -&gt; 登录 ftp 上传 war 包 -&gt; ssh 登录服务器发布，答应我，从今天开始不要浪费时间做这些重复的动作了。记住，看起来差不多重复的流程都可以通过写一些代码来完成。</p>
<p>在了解 jenkins 前，先看下我常用的一段发布脚本可以帮助你理解这个流程，以下的脚本是在服务器端运行的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">TOMCAT_HOME=~/tools/apache-tomcat-9.0.0.M26</span><br><span class="line"></span><br><span class="line">cd ~/sources</span><br><span class="line"></span><br><span class="line">// 把项目源代码从 git 上复制下来</span><br><span class="line">if [ ! -d "RAP" ]</span><br><span class="line">then</span><br><span class="line">    git clone https://github.com/YeDaxia/RAP.git</span><br><span class="line">    cd RAP</span><br><span class="line">else</span><br><span class="line">    cd RAP </span><br><span class="line">    git reset --hard</span><br><span class="line">    git pull</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">// 切换到发布的分枝</span><br><span class="line">git checkout release</span><br><span class="line">echo "current branch is :"</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">// 替换正是环境的配置文件</span><br><span class="line">cp -f ~/deploys/rap/config.properties ~/sources/RAP/src/main/resources/ </span><br><span class="line"></span><br><span class="line">// 打包 war </span><br><span class="line">mvn clean</span><br><span class="line">mvn package</span><br><span class="line"></span><br><span class="line">// 复制 war 到 tomcat 目录下</span><br><span class="line">cp target/*.war  $&#123;TOMCAT_HOME&#125;/webapps/ROOT.war</span><br><span class="line"></span><br><span class="line">// 把 tomcat 给停了，因为 shutdown.sh 经常有问题</span><br><span class="line"><span class="meta">#</span>kill all java process</span><br><span class="line">ps -ef|grep java|grep -v grep|cut -c 9-15|xargs sudo kill -9</span><br><span class="line"></span><br><span class="line">//启动 tomcat</span><br><span class="line">sudo sh $&#123;TOMCAT_HOME&#125;/bin/startup.sh</span><br></pre></td></tr></table></figure>
<p>CI 的过程，就是你提交代码到 github 或者其他代码托管平台，然后触发一个 webhook 请求调用服务器端类似上面的一个过程的代码。</p>
<ul>
<li><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a></li>
</ul>
<p>总之 CI 其实就是一件一劳永逸的事情，上面只是举个例子，无论你是 Android 程序员还是 PHP 程序员，你都应该花点时间掌握这个技能，你可能要学习一下一些构建工具，一点 linux 命令，这可能会麻烦一些，但是这是值得的。</p>
<h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><blockquote>
<p>学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p>
</blockquote>
<p>不要误会，我自己也是一个 IDE 程序员，除了装B，基本这是程序员绕不过去的一个工具，只要你还想自己搭建个服务器，做点东西。</p>
<ul>
<li><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">简明 VIM 练级攻略 - 酷壳</a></li>
</ul>
<p>登录你的 linux 系统，花半个小时跟着玩一下。不要和我一样几年后才意识到去使用那些快捷键，之前都只会愚蠢地使用左右上下，非常低效啊。用进退废，换了 idea 后，eclipse 的快捷键基本就忘的差不多了，我听说有人用 vim + markdown 来写博客的，我现在用的是有道笔记，我觉得这个可操作性还是有的，可以去尝试一下。</p>
<h1 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h1><p>只会用 ↑ ↓ ← →来移动光标真的很低效，很受不了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctrl + u : 清除当前行</span><br><span class="line">ctrl + a : 到命令行首</span><br><span class="line">ctrl + e : 到命令行末</span><br><span class="line">tab: 自动完成</span><br><span class="line">↑ ↓: 命令历史</span><br></pre></td></tr></table></figure>
<h1 id="Chrome-Bookmark"><a href="#Chrome-Bookmark" class="headerlink" title="Chrome Bookmark"></a>Chrome Bookmark</h1><p>你用什么来收集那些小的知识点和一些不错的站点呢？我的答案就是 Chrome 自带的书签了。注册一个 Google 账号，它会同步好你的书签，永不丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://bookmarks</span><br></pre></td></tr></table></figure>
<p>用这个命令可以进入书签管理器，定期清理，有价值的留下，这样你的个人知识库了就越来越丰富了。亮一下我的书签:</p>
<p><img src="/assets/yedaxix_chrome_bookmark.png?imageView2/0/w/500" alt="my bookmark"></p>
<p>好吧，就先介绍到这吧，夜已深。</p>
<hr>
<p>另外，近期打算在 GitChat 做一次分享，手把手教大家去用好上面的工具，如果你有兴趣，可以先加一下这个 Q 群：70948803， 我定用心准备好，不负期待，让大家学到东西，欢迎围观！前 10 名有福利哦 :-) !</p>
<blockquote>
<ul>
<li>我的个人博客：<a href="https://yedaxia.github.io/">https://yedaxia.github.io/</a></li>
<li>github：<a href="https://github.com/YeDaxia" target="_blank" rel="noopener">https://github.com/YeDaxia</a></li>
<li>码云：<a href="https://gitee.com/yeguozhong" target="_blank" rel="noopener">https://gitee.com/yeguozhong</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个程序员应该精挑细选和打磨他的工具箱，这里推荐的东西都是本人使用频次比较高的，不是奇淫巧技，也不需要花很多时间，但是会让你收益超额的，至少对我来说是这样的。&lt;/p&gt;
&lt;p&gt;这是很有诚意的一篇文章，你可以选择一笑而过，也可以默默收藏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术成长" scheme="https://yedaxia.github.io/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>加速前后端并行开发，JApiDocs 可以帮到你</title>
    <link href="https://yedaxia.github.io/How-JApiDocs-Help-You/"/>
    <id>https://yedaxia.github.io/How-JApiDocs-Help-You/</id>
    <published>2017-08-18T05:57:03.000Z</published>
    <updated>2019-01-10T16:08:19.577Z</updated>
    
    <content type="html"><![CDATA[<p>JApiDocs 作为一个衔接前后端开发的的工具，尽可能把重复劳动都自动化了，实现了代码即文档，持续集成接口测试的小目标，非常优雅的解决在前后端并行开发碰到的一些问题。</p>
<a id="more"></a>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>一般公司的开发流程应该是这样的，产品评估会议完了之后，接着就是各就位的设计，开发了，当然这个过程中会有一些反复的交叉。我们这里主要讨论在评估完成之后，原型交给开发的这个节点。在这个节点上，如果没有接口文档，UI 稿也还在设计，那前端开发人员只能无奈的陷入等待，然后后面时间紧迫，不得不加班完成。</p>
<p><img src="/assets/yedaxia_app_product_work_flow.png" alt="develop flow"></p>
<p>接口文档非常重要，但什么时候写？谁来写呢？我的建议是接口的设计应该是交给有一定经验的后端开发人员来提前设计好，然后分给后端人员去实现，同时也交付接口协议给前端，两端并行开发。但实际情况是由于文档本身就是一个工作量，后端人员也不太关心前端的工作进度，而且提前设计的接口后面也可能会有一些小改动，对自己来说得不偿失，所以就变成了后端同学懒得去提前设计，一直等接口开发完了再去完善文档，这可能算好的了，有些团队就直接把一个 URL 贴到聊天框里面了事，前端同学只能去翻聊天记录。</p>
<p>这里顺便提一下没有接口文档的后果，一个生命周期比较长的产品，肯定经历了多个版本的迭代，接口的数量也会变的庞大，新进来的开发已经没办法在短时间之内了解每个接口的作用了，当碰到相同功能的时候，很容易又写了个差不多的接口，重复的接口越来越多，当其中一个有问题时，你要处理的可不仅仅是一个地方；更惨的是客户端人员，这个接口对他来说就是个黑盒子，要打开这个盒子，只能不断找服务端的问问问了，极大的沟通成本啊～</p>
<p>在前后端协作中还有一个问题就是，即使有了完善的 API 文档，在接口没有开发出来之前，要进行接口的测试，只能本地或者通过一些平台(比如 <a href="http://rapapi.org/org/index.do" target="_blank" rel="noopener">rap</a>)去模拟接口生成相关数据，这对于前端开发人员来说也是一个额外的负担。</p>
<h2 id="视频介绍"><a href="#视频介绍" class="headerlink" title="视频介绍"></a>视频介绍</h2><p><a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">JApiDocs</a> 可以以非常优雅的方式帮助 Java 程序员解决上面的问题，让 API 文档这件重要的”小事”不再是一种负担，尤其你如果是用 <a href="https://projects.spring.io/spring-boot/" target="_blank" rel="noopener">spring boot</a>、 <a href="https://www.playframework.com/" target="_blank" rel="noopener">play framework</a> 或者 <a href="http://www.jfinal.com/" target="_blank" rel="noopener">jfinal</a> 的话，你会尤其感受到它的友好。尤其是小步快跑的小团队，希望 Ta 可以帮你们赢得一些时间。</p>
<p>本来想用图文的形式，后来灵感一现，何不用一个简短的视频呢？直接明了，所以硬着头皮第一次录了个视频，恶心的优酷有广告，视频时长3分30秒，不会浪费大家很多时间: <a href="http://v.youku.com/v_show/id_XMjk3NDk0MTY0NA==.html?spm=a2hzp.8244740.0.0" target="_blank" rel="noopener">点击查看</a>。</p>
<h2 id="和其他工具的对比"><a href="#和其他工具的对比" class="headerlink" title="和其他工具的对比"></a>和其他工具的对比</h2><p>JApiDocs 和 <a href="https://swagger.io/" target="_blank" rel="noopener">swagger</a>，<a href="http://apidocjs.com/" target="_blank" rel="noopener">apidocjs</a> 有什么区别呢？这里我无意见看到 github<br>上网友的提的一个 issue ，大家可以感受一下：</p>
<p><img src="/assets/yedaxia_swagger_issue?imageView2/0/w/600" alt=""></p>
<p>这两天把想集成的 rap 功能做好了，终于可以自恋的总结了一下：</p>
<table>
<thead>
<tr>
<th>API 工具</th>
<th>文档支持</th>
<th>语言支持</th>
<th>接口测试</th>
</tr>
</thead>
<tbody>
<tr>
<td>swagger</td>
<td>功能强大，学习成本高，维护成本高</td>
<td>多语言</td>
<td>支持</td>
</tr>
<tr>
<td>apidocjs</td>
<td>学习成本一般，维护成本高</td>
<td>多语言</td>
<td>不支持</td>
</tr>
<tr>
<td>JApiDocs</td>
<td>代码即文档，学习和维护成本低</td>
<td>Java</td>
<td>支持发布到 <a href="http://rapapi.org/org/" target="_blank" rel="noopener">RAP</a></td>
</tr>
</tbody>
</table>
<p>对于 Java 程序员来说，JApiDocs 作为一个衔接前后端开发的的工具，尽可能把重复劳动都自动化了，实现了代码即文档，持续集成接口测试的小目标。反正它已经成为我的首选 API 文档工具了，我希望也可以成为你的首选。</p>
<h2 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h2><p>项目地址：<a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">https://github.com/YeDaxia/JApiDocs</a>，目前用不到，可以先点个星星收藏起来哇。</p>
<p>如果你以前已经在用其他的了，积重难返，我建议你还是用以前的工具；如果你还是手工去创建文档，或者要做一个新的项目，我墙裂建议你马上开始使用 JApiDocs，记得先看文档，运行一下测试用例，5分钟就能从入门到爱不释手～ 有问题欢迎反馈，我会第一时间积极响应。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JApiDocs 作为一个衔接前后端开发的的工具，尽可能把重复劳动都自动化了，实现了代码即文档，持续集成接口测试的小目标，非常优雅的解决在前后端并行开发碰到的一些问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="团队协作" scheme="https://yedaxia.github.io/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
      <category term="JApiDocs" scheme="https://yedaxia.github.io/tags/JApiDocs/"/>
    
      <category term="文档工具" scheme="https://yedaxia.github.io/tags/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发工具" scheme="https://yedaxia.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>一个给 Java 程序员用的 Api 文档生成工具</title>
    <link href="https://yedaxia.github.io/JApiDocs-Introduction-For-Java-Developer/"/>
    <id>https://yedaxia.github.io/JApiDocs-Introduction-For-Java-Developer/</id>
    <published>2017-08-11T06:36:42.000Z</published>
    <updated>2019-01-10T16:08:19.578Z</updated>
    
    <content type="html"><![CDATA[<p>api 文档作为前后端同学的沟通桥梁，其重要性是不言而喻的。目前通用的工具有像<a href="https://github.com/apidoc/apidoc" target="_blank" rel="noopener">apidoc/apidoc</a>，<a href="https://github.com/caixw/apidoc" target="_blank" rel="noopener">caixw/apidoc</a>这样的第三方库，虽然具有语言无关的特性，但是真正用起来额外多了很多工作量，而且维护起来麻烦，这也是笔者设计和开发这个工具的原因，想通过 java 本身的语言特性和结合强大的 IDE ，使得生成和维护 api 文档这件事情变的自然而美好。</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>github地址：<a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">JApiDocs</a></p>
<p>JApiDocs 是一个符合 Java 编程习惯的 Api 文档生成工具。最大程度地利用 Java 的语法特性，你只管用心设计好接口，添加必要的注释，JApiDocs 会帮你导出一份漂亮的 Html 文档，并生成相关的 Java 和 Object-C 相关数据模型代码，从此，Android 和 IOS 的同学可以少敲很多代码了，你也不需要费力维护接口文档的变化，只需要维护好你的代码就可以了。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>以一个 Controller 作为一组接口导出到一个 Html 文件中。</li>
<li>支持生成 Java 和 Object-C 语言的 Response 模型代码。</li>
<li>深度支持 <a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">Spring Boot</a>， <a href="https://www.playframework.com/" target="_blank" rel="noopener">PlayFramework</a>，<a href="http://www.jfinal.com/" target="_blank" rel="noopener">JFinal</a>，不需要额外声明路由。</li>
<li>支持一般的 Java Web 工程，需要在相关方法添加额外的路由。</li>
<li>支持接口声明过时(<code>@Deprecated</code>)，方便的文档目录等。</li>
<li>支持自定义代码生成模板。</li>
</ol>
<h1 id="5分钟集成"><a href="#5分钟集成" class="headerlink" title="5分钟集成"></a>5分钟集成</h1><ol>
<li>我们以 spring 为例，一张图很容易就明白了 JApidocs 是怎么工作的了，你在设计接口的时候可以顺便就把相关的注释给填好了，这和 Java 程序员的编程习惯是保持一致的。</li>
</ol>
<p><img src="/assets/spring-controllers.png" alt="spring controller"></p>
<p>这里你可能会对<code>@ApiDoc</code>注解感到迷惑，这也是唯一需要一点额外工作的地方，别急，下面马上就讲到它。</p>
<ol start="2">
<li><code>@ApiDoc</code> 是我们定义的一个注解，除非程序运行起来，否则我们是没办法知道 <code>response</code> 里面都包含有哪些内容，但是我们明明有了相关的视图类，为了解决这个问题，我们折衷设计了这个基于<code>RetentionPolicy.SOURCE</code>的注解，它不会给现有的代码造成任何的负担。由于是基于 Java 源码进行解析的，所以你不需要依赖我们的 Jar 包，你可以在你自己的工程任意地方添加这个简单的类即可，当然，如果你连这个也不愿意也是没关系的，你只需要直接添加我们的 Jar 包即可，里面已经为你准备好这个类了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiDoc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * result class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	Class&lt;?&gt; value() <span class="keyword">default</span> Null.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * result class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	Class&lt;?&gt; result() <span class="keyword">default</span> Null.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * request url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * request method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function">String <span class="title">method</span><span class="params">()</span> <span class="keyword">default</span> "get"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Null</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你用的是我们深度支持的 MVC 框架，那么你只需要写好返回的视图模型就可以了。</p>
<ol start="3">
<li>集成依赖和运行</li>
</ol>
<p><strong>命令行模式:</strong></p>
<p>下载<code>all</code>包，然后在和这个<code>jar</code>包相同目录下创建名称是<code>docs.config</code>的配置文件，里面可以配置这几个参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">projectPath = 工程目录（必须）</span><br><span class="line">docsPath = 文档输出目录（非必须，默认是$&#123;projectPath&#125;/apidocs）</span><br><span class="line">codeTplPath = 代码模版目录 (非必须，如果你需要自定义生成的代码才会用到。)</span><br><span class="line">mvcFramework = [spring, play, jfinal, generic](非必须，代码内部有判断，如果出现误判的情况，可以通过这个强制指定)</span><br></pre></td></tr></table></figure>
<p>配置好之后，运行该<code>jar</code>包就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ***-all.jar</span><br></pre></td></tr></table></figure>
<p><strong>代码模式</strong></p>
<p>如果想做一些持续集成的话，代码模式还是比较方便的，直接添加依赖或者下载相关<code>jar</code>包，其中<code>min</code>包是不包含第三方依赖的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;io.github.yedaxia:japidocs:1.0&apos;</span><br><span class="line">compile &apos;com.google.code.gson:gson:2.8.0&apos;</span><br><span class="line">compile &apos;com.github.javaparser:javaparser-core:3.3.0&apos;</span><br></pre></td></tr></table></figure>
<p>只需要调用下面一句代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docs.buildHtmlDocs(DocsConfig config);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>自定义输出 Java 和 IOS 代码：</li>
</ol>
<p>你可以把工程里面相关的代码模板文件拷贝出来，然后在配置参数声明好该路径即可，具体的模板文件如下：<br><img src="/assets/darcy_blog_apidocs-code-tpls.png" alt="code template files"></p>
<ol start="5">
<li>更多的用法和不同的框架可以参考我们的示例代码。</li>
</ol>
<h1 id="注意的地方"><a href="#注意的地方" class="headerlink" title="注意的地方"></a>注意的地方</h1><ol>
<li>返回视图类不支持循环引用，会导致 stackoverflow。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserVO</span></span>&#123;</span><br><span class="line">    BookVO book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookKVO</span></span>&#123;</span><br><span class="line">    UserVO user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>JFinal 路由配置必须在 configRoute 方法体里，否则会解析失败。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configRoute</span><span class="params">(Routes me)</span> </span>&#123;</span><br><span class="line">    me.add(<span class="string">"/api/v1/user"</span>, UserController.class);</span><br><span class="line">    me.add(<span class="string">"/api/v1/book"</span>, BookController.class);</span><br><span class="line">    me.add(<span class="keyword">new</span> AmdinRoutes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="支持和反馈"><a href="#支持和反馈" class="headerlink" title="支持和反馈"></a>支持和反馈</h1><p>由于每个人写代码的习惯可能都不一样，虽然已经尽可能考虑到了多种不同的情况，但由于作者本人的认知和精力有限，难免会疏忽或者本身就存在有 bug 的情况，如果你在使用的过程中有碰到困难或者疑问，欢迎提<code>issue</code>或者加扣扣群进行反馈：70948803。</p>
<p>如果你觉得这个项目对你有用，请猛戳 <a href="https://github.com/YeDaxia/JApiDocs" target="_blank" rel="noopener">star</a>，你的支持是我前进的动力！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;api 文档作为前后端同学的沟通桥梁，其重要性是不言而喻的。目前通用的工具有像&lt;a href=&quot;https://github.com/apidoc/apidoc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;apidoc/apidoc&lt;/a&gt;，&lt;a href=&quot;https://github.com/caixw/apidoc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;caixw/apidoc&lt;/a&gt;这样的第三方库，虽然具有语言无关的特性，但是真正用起来额外多了很多工作量，而且维护起来麻烦，这也是笔者设计和开发这个工具的原因，想通过 java 本身的语言特性和结合强大的 IDE ，使得生成和维护 api 文档这件事情变的自然而美好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="团队协作" scheme="https://yedaxia.github.io/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
      <category term="JApiDocs" scheme="https://yedaxia.github.io/tags/JApiDocs/"/>
    
      <category term="文档工具" scheme="https://yedaxia.github.io/tags/%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
    
      <category term="开发工具" scheme="https://yedaxia.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>代码重构的一点总结</title>
    <link href="https://yedaxia.github.io/Android-Code-Refactor-Summary/"/>
    <id>https://yedaxia.github.io/Android-Code-Refactor-Summary/</id>
    <published>2017-08-02T05:57:03.000Z</published>
    <updated>2018-02-03T06:43:34.464Z</updated>
    
    <content type="html"><![CDATA[<p>重构是一件春天播种，秋天收获的事情，要有耐心；正确的方法很重要，循序渐进可能比推翻重来更科学。</p>
<a id="more"></a>
<p>这个总结比较晚了，快相隔一年了，总想挤点什么出来写一下，一方面是避免让自己懒下来，另一方面也是迫使自己复盘，思考这个过程中哪些地方做得还Ok，哪些地方做的不好。</p>
<p>不少公司初期的项目为了快速和低成本开发产品，一开始可能会找外包或者开发能力一般的开发人员来完成，等公司业务上去了，这时候也欠了一屁股的技术债，很幸运，我刚好就当了一回接盘侠。</p>
<p>初接手项目，闻到坏代码的味道，不要急于作出改变，重构是一件需要小心翼翼进行的一件事情，你的每一点改动都会给QA的童鞋带来额外的工作量，尽管你觉得没有问题。所以，第一步要做的就是先把整体的情况先摸个底，先把问题暴露出来，制定好你初步的重构方案。在这个过程中，你可能要先默默的利用空闲时间做好方案，毕竟可能还有很多业务代码要写的，你不得不忍受先在原来的框架上把当前的工作完成。</p>
<p>在我审视整个项目的时候，我发现存在有如下的问题：</p>
<ol>
<li>多个已经不在维护的第三方库，尤其是网络库，没有进行二次封装，耦合度非常高；</li>
<li>sdk版本也近一年没有进行更新过；</li>
<li>一些库使用方法不恰当，可能会带来内存泄漏和组件状态不正确(比如所在的 Activity 已经销毁)导致的崩溃问题；</li>
<li>有不少重复性很高的代码散落在各处；</li>
<li>变量名和方法名有些随意，驼峰和下划线风格并存；</li>
<li>逻辑过于冗长的方法，比如和 H5 页面的协议处理，近 1K 行的 <code>if else</code>；</li>
<li>没有考虑一些边界条件，比如请求失败重试，没有数据的情况；</li>
<li>存在不少的魔数，往往在一些关键的逻辑里面，涉及到很多状态的变化处理。</li>
<li>没有懒加载用户还不需要的资源，页面 overdraw 的情况严重等；</li>
<li>还有一些情况暂时回想不起来，总之情况比较恶劣，骂人的冲动都有。</li>
</ol>
<p>整理好问题和写好初步的重构方案之后，接下来就可以找你的老大去聊这个事情了，一般来说都会得到支持，这样也可以让上面知道你在埋头苦干的时候是在干嘛，当时的想法是想推翻重建的，做法就是一个新的项目工程和一个旧的并行开发，有新的开发任务就先在旧的工程上开发，然后新的工程就逐步赶上和替代，最后一次性把新的 app 交付给 QA 进行一次从头到尾的测试，当时评估这样应该会比在原来的基础上改耗费的时间要更少一些。但很快发现这样做行不通，一方面需求在不断变化，引起的变化两边工程都要改动；另外在开发进度上会和 iOS 端很难同步。所以很快不得改变了思路，整合新旧的代码，然后在同一条工程线上进行重构，这样一来，必然就多了很多整合的工作，重构变成了一个抽丝剥茧的过程，没那么痛快了，但好处就是每一步做的工作，都可以被看见。</p>
<p>既然是想改善代码，那肯定要先阻断烂代码再被添加进来，因此，第一件事要先建立起代码的相关规范，有可能的话，要尽可能加入 Code Review 这一流程来驱动规范的落实。重构的思路是从底层往高层，从变化少到变化频繁，比如底层的网络请求、图片缓存处理，这是变化少的部分，而页面和相关逻辑就是变化频繁的部分，从底层到高层好理解，从变化少到变化多则是对应经常变化的需求，或许在下个版本你就可以顺便把它重新做一遍，原来的代码彻底删除掉了。这里分享一部分具体的做法，可能对你有启发：</p>
<ol>
<li>在改写网络层的时候，这次通过策略模式来分离了网络请求过程和数据解析过程，这样不管以后是用 okhttp 还是 volley ，是 Json 还是 Protocol Buffers 结构的数据，喜欢用 gson 还是 fastjson ， 都只需要修改少量的代码，而且对上层调用没有任何影响。另外，由于新和旧的网络库不一样，为了减少 jar 包的数量，决定对旧的接口进行完全的兼容，但底层用的还是新的网络库。改写这一层后，对于新的代码就用新的接口，以前的就可以等待合适的时机再进行替换了。</li>
<li>这个 app 很多混合开发的地方，很多 H5 页面的点击需要调用起原生的方法，由于自定义的跳转协议数量非常多，原来的处理方法已经超过近 1K 行的代码，这样必然导致阅读和修改困难的问题，这里我采用了大家熟悉的状态模式把相关职责分散到不同的类里面了。</li>
<li>很多页面都有相似的过程，比如从从数据加载到加载失败处理，刷新和加载更多等，这些可以通过模板方法把相关的逻辑封装到基类里面，然后让子类去实现变化的部分，比如不同的视图和数据的绑定，可以大大减少代码量。</li>
</ol>
<p>还有一些技巧已经回忆不起来了，整个重构过程的彻底完成花了差不多半年的时间，期间经历了好几个版本的迭代。从效果来看，重构后带来的好处是显著的：首先提升了今后的开发效率，拥有了更好的可维护性，其次 bug 的数量和崩溃率也有了大幅度的好转，最后得益于各种库的升级和优化，app 的性能也得到了不少的提升。总结一下，重构是一件春天播种，秋天收获的事情，要有耐心；正确的方法很重要，循序渐进可能比推翻重来更科学。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重构是一件春天播种，秋天收获的事情，要有耐心；正确的方法很重要，循序渐进可能比推翻重来更科学。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://yedaxia.github.io/tags/Android/"/>
    
      <category term="代码重构" scheme="https://yedaxia.github.io/tags/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>记录网页爬虫注意的几个问题</title>
    <link href="https://yedaxia.github.io/SomeWebSpiderProblem/"/>
    <id>https://yedaxia.github.io/SomeWebSpiderProblem/</id>
    <published>2017-07-07T06:37:19.000Z</published>
    <updated>2018-02-03T06:52:16.800Z</updated>
    
    <content type="html"><![CDATA[<p>能随意地收集大量的信息是作为程序员一个酷炫的技能之一。他们谙习这些二进制存储和流通，不管是处于正义还是邪恶的目的，这些公开或者半公开的数据对于他们来说唾手可得！是不是有大片开场的画面感！！当然我是遵纪守法的好公民，最近需要抓取某个站点的公开数据，结合以前爬取的一些经验做个总结。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>能随意地收集大量的信息是作为程序员一个酷炫的技能之一。他们谙习这些二进制存储和流通，不管是处于正义还是邪恶的目的，这些公开或者半公开的数据对于他们来说唾手可得！是不是有大片开场的画面感！！当然我是遵纪守法的好公民，最近需要抓取某个站点的公开数据，结合以前爬取的一些经验做个总结。</p>
<h1 id="设置合理的user-agent"><a href="#设置合理的user-agent" class="headerlink" title="设置合理的user-agent"></a>设置合理的user-agent</h1><p>一些站点会把这个当作很基本的过滤条件，我们就不碰壁了，直接找个浏览器粘贴一个，有些文章介绍用一些爬虫的<code>user-agent</code>，但是对方可能会有相关的爬虫服务器的 iplist，不过这种情况不多见，可以试一下。</p>
<h1 id="设置合理的爬取间隔"><a href="#设置合理的爬取间隔" class="headerlink" title="设置合理的爬取间隔"></a>设置合理的爬取间隔</h1><p>过于频繁的流量很容易被监控到，当然除了一些没人管的站点，通常请求ip会被对方禁用一段时间，严重的可能会拉入黑名单，这就浪费掉一个 ip 地址了。如果你不是很急的话，我一般设置个 1 到 10 秒的随机访问间隔，单线程执行，慢慢爬。一般来说很多站点都能接受这样的方式，也不会给对方运维人员造成压力，如果还有限制同个 ip 的访问次数，那我们还有代理招。</p>
<h1 id="需要登录权限"><a href="#需要登录权限" class="headerlink" title="需要登录权限"></a>需要登录权限</h1><p>有登录就有注册，以前很多注册是需要验证邮箱，通过SMTP协议读取邮件内容实现自动化是个思路，前提你也要有很多邮箱地址，牛逼的你可以自己搭建个邮件服务器，要多少有多少。现在很多是通过手机号码的验证码了，这个就麻烦了，首先要有很多设备插很多sim卡接收短信，然后还要在这些设备上把数据传到你运行的那台机子解析出验证码才能把整个流程自动化。反正我是没试过，一般我都是手工注册几个。</p>
<p>登录的话就会简单一些，把用户名和密码post上去之后根据服务端返回的<code>Set-Cookie</code>设置好相关请求头就行了，甚至有些框架都帮你处理好了。如果需要验证码的话，出门左拐去购买破解验证码的接口或者自己实现吧，拿到凭证后就可以在相关页面里面横冲直撞了。当然，你也可以像我一样手动在浏览器上登录，拿到<code>Set-Cookie</code>之后在进行后面的操作。</p>
<h1 id="增量爬取"><a href="#增量爬取" class="headerlink" title="增量爬取"></a>增量爬取</h1><p>如果爬的内容非常多，你永远也不知道在什么时候就 GameOver 了，因此一定要保存好你的进度，通常来说抓取工作都很重，抓到半天然后从头开始，It sucks ! 多写一点代码换来的好处是值得的。</p>
<h1 id="代理魔法好"><a href="#代理魔法好" class="headerlink" title="代理魔法好"></a>代理魔法好</h1><p>关于拉内容，这里介绍的是终极大招了。有了代理服务器，你就相当于找到了多个帮你干活的小弟，而且还是远程指挥，被封了也不会影响到你的本尊。</p>
<p>代理的来源：你可以自己用工具去扫描全网找到可用的免费代理，也可以像笔者一样偷懒去购买一些可用的代理。</p>
<p>代理的使用策略：你可能拥有了便宜甚至免费的代理地址，但是这里面很多可能都没法使用，或者现在能用，待会就不能用了，因此在使用之前应该测试一下，及时移除不能用的地址，提高效率。另外，注意不要用一个代理地址连续范围，笔者的策略一般是每个请求顺序换一个代理地址，如果数量足够多的前提下，你可以尽可能地提升你的爬取线程或者进程数，由于每个 ip 的访问间隔足够长，这样也不会被封 ip 。</p>
<h1 id="内容解析"><a href="#内容解析" class="headerlink" title="内容解析"></a>内容解析</h1><p>在没认识<a href="https://jsoup.org/" target="_blank" rel="noopener">Jsoup</a>之前，笔者一般通过正则表达式和字符串的处理来滤出想要的内容，如果你还在拼难写的正则表达式，不妨可以试一下 Jsoup 。</p>
<h1 id="Ajax异步内容"><a href="#Ajax异步内容" class="headerlink" title="Ajax异步内容"></a>Ajax异步内容</h1><p>现在很多单页的应用都是先把 js 和基本的页面框架先加载，然后在异步请求一些其他的内容，比如很多的下拉到底部请求下一页的列表数据。对于这样的情况，我建议还是读一下它的 js 代码，然后模拟这个过程，这样爬取效率会更高一些；另外也可以<a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">selenium</a>这样的工具来模拟浏览器的执行，这个笔者还没用过。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抓取信息其实是个攻与防的过程，总结规律，多测试和践行你的想法，找到合适的策略。最后，善用工具，但行好事哈～</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>java 爬虫框架：<a href="https://github.com/code4craft/webmagic" target="_blank" rel="noopener">webmagic</a></li>
<li>html解析框架：<a href="https://jsoup.org/" target="_blank" rel="noopener">jsoup</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;能随意地收集大量的信息是作为程序员一个酷炫的技能之一。他们谙习这些二进制存储和流通，不管是处于正义还是邪恶的目的，这些公开或者半公开的数据对于他们来说唾手可得！是不是有大片开场的画面感！！当然我是遵纪守法的好公民，最近需要抓取某个站点的公开数据，结合以前爬取的一些经验做个总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络爬虫" scheme="https://yedaxia.github.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
